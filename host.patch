diff -rupN qemu-1.0.1/config-all-devices.mak modified_QEMU/config-all-devices.mak
--- qemu-1.0.1/config-all-devices.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/config-all-devices.mak	2015-02-11 23:03:10.644972000 -0800
@@ -0,0 +1,44 @@
+CONFIG_ACPI=y
+CONFIG_AHCI=y
+CONFIG_APM=y
+CONFIG_DMA=y
+CONFIG_DP8393X=y
+CONFIG_DS1225Y=y
+CONFIG_E1000_PCI=y
+CONFIG_EEPRO100_PCI=y
+CONFIG_ESP=y
+CONFIG_FDC=y
+CONFIG_G364FB=y
+CONFIG_I8254=y
+CONFIG_I8259=y
+CONFIG_IDE_CORE=y
+CONFIG_IDE_ISA=y
+CONFIG_IDE_PCI=y
+CONFIG_IDE_PIIX=y
+CONFIG_IDE_QDEV=y
+CONFIG_ISA_MMIO=y
+CONFIG_LSI_SCSI_PCI=y
+CONFIG_MIPSNET=y
+CONFIG_NE2000_ISA=y
+CONFIG_NE2000_PCI=y
+CONFIG_PARALLEL=y
+CONFIG_PCI=y
+CONFIG_PCKBD=y
+CONFIG_PCNET_COMMON=y
+CONFIG_PCNET_PCI=y
+CONFIG_PCSPK=y
+CONFIG_PFLASH_CFI01=y
+CONFIG_PIIX4=y
+CONFIG_RC4030=y
+CONFIG_RTL8139_PCI=y
+CONFIG_SERIAL=y
+CONFIG_SOUND=y
+CONFIG_USB_EHCI=y
+CONFIG_USB_OHCI=y
+CONFIG_USB_UHCI=y
+CONFIG_VGA_ISA=y
+CONFIG_VGA_ISA_MM=y
+CONFIG_VGA_PCI=y
+CONFIG_VIRTIO=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VMWARE_VGA=y
diff -rupN qemu-1.0.1/config-host.h modified_QEMU/config-host.h
--- qemu-1.0.1/config-host.h	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/config-host.h	2015-02-11 23:03:10.933972000 -0800
@@ -0,0 +1,63 @@
+/* Automatically generated by create_config - do not modify */
+#define CONFIG_QEMU_PREFIX "/usr/local"
+#define CONFIG_QEMU_BINDIR "/usr/local/bin"
+#define CONFIG_QEMU_LIBDIR "/usr/local/lib"
+#define CONFIG_QEMU_INCLUDEDIR "/usr/local/include"
+#define CONFIG_QEMU_MANDIR "/usr/local/share/man"
+#define CONFIG_QEMU_DATADIR "/usr/local/share/qemu"
+#define CONFIG_QEMU_SYSCONFDIR "/usr/local/etc"
+#define CONFIG_QEMU_DOCDIR "/usr/local/share/doc/qemu"
+#define CONFIG_QEMU_CONFDIR "/usr/local/etc/qemu"
+#define HOST_X86_64 1
+#define HOST_LONG_BITS 64
+#define CONFIG_POSIX 1
+#define CONFIG_LINUX 1
+#define CONFIG_SLIRP 1
+#define CONFIG_SMBD_COMMAND "/usr/sbin/smbd"
+#define CONFIG_AC97 1
+#define CONFIG_ES1370 1
+#define CONFIG_SB16 1
+#define CONFIG_HDA 1
+#define CONFIG_AUDIO_DRIVERS \
+    &oss_audio_driver,\
+
+#define CONFIG_OSS 1
+#define CONFIG_BDRV_WHITELIST \
+    NULL
+#define CONFIG_VNC 1
+#define CONFIG_FNMATCH 1
+#define QEMU_VERSION "1.0,1"
+#define QEMU_PKGVERSION ""
+#define CONFIG_ATFILE 1
+#define CONFIG_UTIMENSAT 1
+#define CONFIG_PIPE2 1
+#define CONFIG_ACCEPT4 1
+#define CONFIG_SPLICE 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_FALLOCATE 1
+#define CONFIG_SYNC_FILE_RANGE 1
+#define CONFIG_FIEMAP 1
+#define CONFIG_DUP3 1
+#define CONFIG_EPOLL 1
+#define CONFIG_EPOLL_CREATE1 1
+#define CONFIG_EPOLL_PWAIT 1
+#define CONFIG_INOTIFY 1
+#define CONFIG_INOTIFY1 1
+#define CONFIG_BYTESWAP_H 1
+#define CONFIG_ATTR 1
+#define CONFIG_VIRTFS 1
+#define CONFIG_IOVEC 1
+#define CONFIG_PREADV 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_FDATASYNC 1
+#define CONFIG_MADVISE 1
+#define CONFIG_POSIX_MADVISE 1
+#define CONFIG_SMARTCARD 1
+#define CONFIG_UNAME_RELEASE ""
+#define CONFIG_ZERO_MALLOC 1
+#define CONFIG_UCONTEXT_COROUTINE 1
+#define CONFIG_OPEN_BY_HANDLE 1
+#define CONFIG_LINUX_MAGIC_H 1
+#define CONFIG_TRACE_NOP 1
+#define CONFIG_TRACE_FILE trace
+#define CONFIG_TRACE_DEFAULT 1
diff -rupN qemu-1.0.1/config-host.h-timestamp modified_QEMU/config-host.h-timestamp
--- qemu-1.0.1/config-host.h-timestamp	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/config-host.h-timestamp	2015-02-11 23:03:10.916972000 -0800
@@ -0,0 +1,63 @@
+/* Automatically generated by create_config - do not modify */
+#define CONFIG_QEMU_PREFIX "/usr/local"
+#define CONFIG_QEMU_BINDIR "/usr/local/bin"
+#define CONFIG_QEMU_LIBDIR "/usr/local/lib"
+#define CONFIG_QEMU_INCLUDEDIR "/usr/local/include"
+#define CONFIG_QEMU_MANDIR "/usr/local/share/man"
+#define CONFIG_QEMU_DATADIR "/usr/local/share/qemu"
+#define CONFIG_QEMU_SYSCONFDIR "/usr/local/etc"
+#define CONFIG_QEMU_DOCDIR "/usr/local/share/doc/qemu"
+#define CONFIG_QEMU_CONFDIR "/usr/local/etc/qemu"
+#define HOST_X86_64 1
+#define HOST_LONG_BITS 64
+#define CONFIG_POSIX 1
+#define CONFIG_LINUX 1
+#define CONFIG_SLIRP 1
+#define CONFIG_SMBD_COMMAND "/usr/sbin/smbd"
+#define CONFIG_AC97 1
+#define CONFIG_ES1370 1
+#define CONFIG_SB16 1
+#define CONFIG_HDA 1
+#define CONFIG_AUDIO_DRIVERS \
+    &oss_audio_driver,\
+
+#define CONFIG_OSS 1
+#define CONFIG_BDRV_WHITELIST \
+    NULL
+#define CONFIG_VNC 1
+#define CONFIG_FNMATCH 1
+#define QEMU_VERSION "1.0,1"
+#define QEMU_PKGVERSION ""
+#define CONFIG_ATFILE 1
+#define CONFIG_UTIMENSAT 1
+#define CONFIG_PIPE2 1
+#define CONFIG_ACCEPT4 1
+#define CONFIG_SPLICE 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_FALLOCATE 1
+#define CONFIG_SYNC_FILE_RANGE 1
+#define CONFIG_FIEMAP 1
+#define CONFIG_DUP3 1
+#define CONFIG_EPOLL 1
+#define CONFIG_EPOLL_CREATE1 1
+#define CONFIG_EPOLL_PWAIT 1
+#define CONFIG_INOTIFY 1
+#define CONFIG_INOTIFY1 1
+#define CONFIG_BYTESWAP_H 1
+#define CONFIG_ATTR 1
+#define CONFIG_VIRTFS 1
+#define CONFIG_IOVEC 1
+#define CONFIG_PREADV 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_FDATASYNC 1
+#define CONFIG_MADVISE 1
+#define CONFIG_POSIX_MADVISE 1
+#define CONFIG_SMARTCARD 1
+#define CONFIG_UNAME_RELEASE ""
+#define CONFIG_ZERO_MALLOC 1
+#define CONFIG_UCONTEXT_COROUTINE 1
+#define CONFIG_OPEN_BY_HANDLE 1
+#define CONFIG_LINUX_MAGIC_H 1
+#define CONFIG_TRACE_NOP 1
+#define CONFIG_TRACE_FILE trace
+#define CONFIG_TRACE_DEFAULT 1
diff -rupN qemu-1.0.1/config-host.ld modified_QEMU/config-host.ld
--- qemu-1.0.1/config-host.ld	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/config-host.ld	2015-02-11 23:03:06.898966000 -0800
@@ -0,0 +1 @@
+SEARCH_DIR("/usr/x86_64-redhat-linux/lib64"); SEARCH_DIR("/usr/local/lib64"); SEARCH_DIR("/lib64"); SEARCH_DIR("/usr/lib64"); SEARCH_DIR("/usr/x86_64-redhat-linux/lib"); SEARCH_DIR("/usr/lib64"); SEARCH_DIR("/usr/local/lib"); SEARCH_DIR("/lib"); SEARCH_DIR("/usr/lib");
diff -rupN qemu-1.0.1/config-host.mak modified_QEMU/config-host.mak
--- qemu-1.0.1/config-host.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/config-host.mak	2015-02-11 23:03:06.963966000 -0800
@@ -0,0 +1,98 @@
+# Automatically generated by configure - do not modify
+# Configured with: './configure' '--target-list=mips64-softmmu'
+all:
+prefix=/usr/local
+bindir=${prefix}/bin
+libdir=${prefix}/lib
+includedir=${prefix}/include
+mandir=${prefix}/share/man
+datadir=${prefix}/share/qemu
+sysconfdir=${prefix}/etc
+docdir=${prefix}/share/doc/qemu
+confdir=${prefix}/etc/qemu
+ARCH=x86_64
+STRIP=strip
+HOST_LONG_BITS=64
+CONFIG_POSIX=y
+CONFIG_LINUX=y
+CONFIG_SLIRP=y
+CONFIG_SMBD_COMMAND="/usr/sbin/smbd"
+CONFIG_AC97=y
+CONFIG_ES1370=y
+CONFIG_SB16=y
+CONFIG_HDA=y
+CONFIG_AUDIO_DRIVERS=oss
+CONFIG_OSS=y
+CONFIG_BDRV_WHITELIST=
+CONFIG_VNC=y
+CONFIG_FNMATCH=y
+VERSION=1.0,1
+PKGVERSION=
+SRC_PATH=/home/maryam/Documents/codeWithSmpEnabled/host_ayaz89
+TARGET_DIRS=mips64-softmmu
+CONFIG_ATFILE=y
+CONFIG_UTIMENSAT=y
+CONFIG_PIPE2=y
+CONFIG_ACCEPT4=y
+CONFIG_SPLICE=y
+CONFIG_EVENTFD=y
+CONFIG_FALLOCATE=y
+CONFIG_SYNC_FILE_RANGE=y
+CONFIG_FIEMAP=y
+CONFIG_DUP3=y
+CONFIG_EPOLL=y
+CONFIG_EPOLL_CREATE1=y
+CONFIG_EPOLL_PWAIT=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY1=y
+CONFIG_BYTESWAP_H=y
+GLIB_CFLAGS=-pthread -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include 
+CONFIG_ATTR=y
+CONFIG_VIRTFS=y
+INSTALL_BLOBS=yes
+CONFIG_IOVEC=y
+CONFIG_PREADV=y
+CONFIG_SIGNALFD=y
+CONFIG_FDATASYNC=y
+CONFIG_MADVISE=y
+CONFIG_POSIX_MADVISE=y
+CONFIG_SMARTCARD=y
+CONFIG_UNAME_RELEASE=""
+CONFIG_ZERO_MALLOC=y
+CONFIG_UCONTEXT_COROUTINE=y
+CONFIG_OPEN_BY_HANDLE=y
+CONFIG_LINUX_MAGIC_H=y
+HOST_USB=linux
+TRACE_BACKEND=nop
+CONFIG_TRACE_NOP=y
+CONFIG_TRACE_FILE=trace
+CONFIG_TRACE_DEFAULT=y
+TOOLS=qemu-ga$(EXESUF) qemu-nbd$(EXESUF) qemu-img$(EXESUF) qemu-io$(EXESUF) 
+CHECKS=
+ROMS=optionrom
+MAKE=make
+INSTALL=install
+INSTALL_DIR=install -d -m 0755
+INSTALL_DATA=install -c -m 0644
+INSTALL_PROG=install -c -m 0755
+PYTHON=python
+CC=gcc
+CC_I386=$(CC) -m32
+HOST_CC=gcc
+AR=ar
+OBJCOPY=objcopy
+LD=ld
+WINDRES=windres
+LIBTOOL=libtool
+CFLAGS=-O2 -g 
+QEMU_CFLAGS=-fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing  -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits
+QEMU_INCLUDES=-I$(SRC_PATH)/slirp -I. -I$(SRC_PATH) -I$(SRC_PATH)/fpu
+HELPER_CFLAGS=
+LDFLAGS=-Wl,--warn-common -Wl,-z,relro -Wl,-z,now -pie -m64 -g 
+ARLIBS_BEGIN=
+ARLIBS_END=
+LIBS+=-pthread -lgthread-2.0 -pthread -lglib-2.0  
+LIBS_TOOLS+=
+EXESUF=
+LIBS_QGA+=-lgthread-2.0 -pthread -lglib-2.0  
+subdir-mips64-softmmu: subdir-libhw64
diff -rupN qemu-1.0.1/config.log modified_QEMU/config.log
--- qemu-1.0.1/config.log	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/config.log	2015-02-11 23:03:06.688966000 -0800
@@ -0,0 +1,428 @@
+gcc -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -c -o /tmp/qemu-conf-30416-9038-29188.o /tmp/qemu-conf-22200-9038-22857.c
+/tmp/qemu-conf-22200-9038-22857.c:2:2: error: #error Not defined
+ #error Not defined
+  ^
+gcc -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -c -o /tmp/qemu-conf-30416-9038-29188.o /tmp/qemu-conf-22200-9038-22857.c
+gcc -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -c -o /tmp/qemu-conf-30416-9038-29188.o /tmp/qemu-conf-22200-9038-22857.c
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -c -o /tmp/qemu-conf-30416-9038-29188.o /tmp/qemu-conf-22200-9038-22857.c
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:1:1: warning: control reaches end of non-void function [-Wreturn-type]
+ int main(void) {}
+ ^
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g
+gcc -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -fPIE -DPIE -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -m64 -g -pie
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -pie -m64 -g -Wl,-z,relro -Wl,-z,now
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/inttypes.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -c -o /tmp/qemu-conf-30416-9038-29188.o /tmp/qemu-conf-22200-9038-22857.c
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -c -o /tmp/qemu-conf-30416-9038-29188.o /tmp/qemu-conf-22200-9038-22857.c
+In file included from /usr/include/sched.h:22:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c:3:6: warning: function declaration isn’t a prototype [-Wstrict-prototypes]
+ void foo()
+      ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘foo’:
+/tmp/qemu-conf-22200-9038-22857.c:3:6: warning: old-style function definition [-Wold-style-definition]
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lz
+In file included from /usr/include/limits.h:25:0,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/limits.h:168,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/syslimits.h:7,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/limits.h:34,
+                 from /usr/include/zconf.h:395,
+                 from /usr/include/zlib.h:34,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lxenstore -lxenctrl -lxenguest
+/tmp/qemu-conf-22200-9038-22857.c:1:21: fatal error: xenctrl.h: No such file or directory
+ #include <xenctrl.h>
+                     ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lxenstore -lxenctrl -lxenguest
+/tmp/qemu-conf-22200-9038-22857.c:1:21: fatal error: xenctrl.h: No such file or directory
+ #include <xenctrl.h>
+                     ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lxenstore -lxenctrl -lxenguest
+/tmp/qemu-conf-22200-9038-22857.c:1:21: fatal error: xenctrl.h: No such file or directory
+ #include <xenctrl.h>
+                     ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lxenstore -lxenctrl -lxenguest
+/tmp/qemu-conf-22200-9038-22857.c:1:21: fatal error: xenctrl.h: No such file or directory
+ #include <xenctrl.h>
+                     ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+/tmp/qemu-conf-22200-9038-22857.c:1:27: fatal error: gnutls/gnutls.h: No such file or directory
+ #include <gnutls/gnutls.h>
+                           ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lsasl2
+/tmp/qemu-conf-22200-9038-22857.c:1:23: fatal error: sasl/sasl.h: No such file or directory
+ #include <sasl/sasl.h>
+                       ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -ljpeg
+In file included from /usr/include/stdio.h:27:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c:2:21: fatal error: jpeglib.h: No such file or directory
+ #include <jpeglib.h>
+                     ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lpng
+/tmp/qemu-conf-22200-9038-22857.c:2:17: fatal error: png.h: No such file or directory
+ #include <png.h>
+                 ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -luuid
+/tmp/qemu-conf-22200-9038-22857.c:1:23: fatal error: uuid/uuid.h: No such file or directory
+ #include <uuid/uuid.h>
+                       ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+/tmp/qemu-conf-22200-9038-22857.c:1:21: fatal error: xfs/xfs.h: No such file or directory
+ #include <xfs/xfs.h>
+                     ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lvdeplug
+/tmp/qemu-conf-22200-9038-22857.c:1:24: fatal error: libvdeplug.h: No such file or directory
+ #include <libvdeplug.h>
+                        ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lbrlapi
+/tmp/qemu-conf-22200-9038-22857.c:1:20: fatal error: brlapi.h: No such file or directory
+ #include <brlapi.h>
+                    ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lncurses
+/tmp/qemu-conf-22200-9038-22857.c:1:20: fatal error: curses.h: No such file or directory
+ #include <curses.h>
+                    ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lcurses
+/tmp/qemu-conf-22200-9038-22857.c:1:20: fatal error: curses.h: No such file or directory
+ #include <curses.h>
+                    ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+/tmp/qemu-conf-22200-9038-22857.c:1:23: fatal error: curl/curl.h: No such file or directory
+ #include <curl/curl.h>
+                       ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+/tmp/qemu-conf-22200-9038-22857.c:1:19: fatal error: check.h: No such file or directory
+ #include <check.h>
+                   ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+/tmp/qemu-conf-22200-9038-22857.c:1:33: fatal error: bluetooth/bluetooth.h: No such file or directory
+ #include <bluetooth/bluetooth.h>
+                                 ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/pthread.h:21:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:2:1: warning: null argument where non-null required (argument 1) [-Wnonnull]
+ int main(void) { pthread_create(0,0,0,0); return 0; }
+ ^
+/tmp/qemu-conf-22200-9038-22857.c:2:1: warning: null argument where non-null required (argument 3) [-Wnonnull]
+/tmp/cco6IFT6.o: In function `main':
+/tmp/qemu-conf-22200-9038-22857.c:2: undefined reference to `pthread_create'
+collect2: error: ld returned 1 exit status
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -pthread
+In file included from /usr/include/pthread.h:21:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:2:1: warning: null argument where non-null required (argument 1) [-Wnonnull]
+ int main(void) { pthread_create(0,0,0,0); return 0; }
+ ^
+/tmp/qemu-conf-22200-9038-22857.c:2:1: warning: null argument where non-null required (argument 3) [-Wnonnull]
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lrbd -lrados
+In file included from /usr/include/stdio.h:27:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c:2:24: fatal error: rbd/librbd.h: No such file or directory
+ #include <rbd/librbd.h>
+                        ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -laio
+/tmp/qemu-conf-22200-9038-22857.c:1:20: fatal error: libaio.h: No such file or directory
+ #include <libaio.h>
+                    ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/stdio.h:27:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/sys/types.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:4:31: warning: unused variable ‘iov’ [-Wunused-variable]
+ int main(void) { struct iovec iov; return 0; }
+                               ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/sys/types.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:4:18: warning: statement with no effect [-Wunused-value]
+ int main(void) { preadv; }
+                  ^
+/tmp/qemu-conf-22200-9038-22857.c:4:1: warning: control reaches end of non-void function [-Wreturn-type]
+ int main(void) { preadv; }
+ ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lfdt
+/usr/bin/ld: cannot find -lfdt
+collect2: error: ld returned 1 exit status
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -lGL
+/tmp/qemu-conf-22200-9038-22857.c:1:22: fatal error: X11/Xlib.h: No such file or directory
+ #include <X11/Xlib.h>
+                      ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/sys/types.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:2:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/stdint.h:25:0,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/stdint.h:9,
+                 from /usr/include/sys/inotify.h:21,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/stdint.h:25:0,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/stdint.h:9,
+                 from /usr/include/sys/inotify.h:21,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/fcntl.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:3:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:7:5: warning: implicit declaration of function ‘utimensat’ [-Wimplicit-function-declaration]
+     utimensat(AT_FDCWD, "foo", NULL, 0);
+     ^
+/tmp/qemu-conf-22200-9038-22857.c:7:5: warning: nested extern declaration of ‘utimensat’ [-Wnested-externs]
+/tmp/qemu-conf-22200-9038-22857.c:8:5: warning: implicit declaration of function ‘futimens’ [-Wimplicit-function-declaration]
+     futimens(0, NULL);
+     ^
+/tmp/qemu-conf-22200-9038-22857.c:8:5: warning: nested extern declaration of ‘futimens’ [-Wnested-externs]
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/unistd.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/sys/socket.h:22:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/unistd.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:9:11: warning: ‘fd’ is used uninitialized in this function [-Wuninitialized]
+     splice(STDIN_FILENO, NULL, fd, NULL, len, SPLICE_F_MOVE);
+           ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+/tmp/qemu-conf-22200-9038-22857.c:1:0: warning: "_GNU_SOURCE" redefined [enabled by default]
+ #define _GNU_SOURCE
+ ^
+<command-line>:0:0: note: this is the location of the previous definition
+In file included from /usr/include/unistd.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:2:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/stdint.h:25:0,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/stdint.h:9,
+                 from /usr/include/sys/eventfd.h:21,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:5:9: warning: unused variable ‘efd’ [-Wunused-variable]
+     int efd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
+         ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/fcntl.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/fcntl.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/sys/ioctl.h:21:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/unistd.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/stdint.h:25:0,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/stdint.h:9,
+                 from /usr/include/sys/epoll.h:21,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/stdint.h:25:0,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/stdint.h:9,
+                 from /usr/include/sys/epoll.h:21,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:13:5: warning: statement with no effect [-Wunused-value]
+     epoll_create1;
+     ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/stdint.h:25:0,
+                 from /usr/lib/gcc/x86_64-redhat-linux/4.8.3/include/stdint.h:9,
+                 from /usr/include/sys/epoll.h:21,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/byteswap.h:21:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+/tmp/qemu-conf-22200-9038-22857.c:1:24: fatal error: sys/endian.h: No such file or directory
+ #include <sys/endian.h>
+                        ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -Werror -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g -liscsi
+/tmp/qemu-conf-22200-9038-22857.c:1:25: fatal error: iscsi/iscsi.h: No such file or directory
+ #include <iscsi/iscsi.h>
+                         ^
+compilation terminated.
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/signal.h:28:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:3:32: warning: ‘id’ is used uninitialized in this function [-Wuninitialized]
+ int main(void) { clockid_t id; return clock_gettime(id, NULL); }
+                                ^
+/tmp/qemu-conf-22200-9038-22857.c:3:28: note: ‘id’ was declared here
+ int main(void) { clockid_t id; return clock_gettime(id, NULL); }
+                            ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/unistd.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/sys/types.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/sys/mman.h:22:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/ucontext.h:23:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:2:1: warning: control reaches end of non-void function [-Wreturn-type]
+ int main(void) { makecontext(0, 0, 0); }
+ ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+In file included from /usr/include/fcntl.h:25:0,
+                 from /tmp/qemu-conf-22200-9038-22857.c:1:
+/usr/include/features.h:327:4: warning: #warning _FORTIFY_SOURCE requires compiling with optimization (-O) [-Wcpp]
+ #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
+    ^
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:2:25: warning: control reaches end of non-void function [-Wreturn-type]
+ int main(void) { struct file_handle fh; open_by_handle_at(0, &fh, 0); }
+                         ^
+gcc -fPIE -DPIE -m64 -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fstack-protector-all -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -o /tmp/qemu-conf-26154-9038-309.exe /tmp/qemu-conf-22200-9038-22857.c -Wl,-z,relro -Wl,-z,now -pie -m64 -g
+/tmp/qemu-conf-22200-9038-22857.c: In function ‘main’:
+/tmp/qemu-conf-22200-9038-22857.c:3:1: warning: control reaches end of non-void function [-Wreturn-type]
+ }
+ ^
diff -rupN qemu-1.0.1/configure modified_QEMU/configure
--- qemu-1.0.1/configure	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/configure	2015-01-29 09:21:18.000000000 -0800
@@ -914,6 +914,7 @@ m68k-linux-user \
 microblaze-linux-user \
 microblazeel-linux-user \
 mips-linux-user \
+mips64-linux-user \
 mipsel-linux-user \
 ppc-linux-user \
 ppc64-linux-user \
@@ -3422,6 +3423,7 @@ case "$target_arch2" in
     TARGET_ARCH=mips64
     TARGET_BASE_ARCH=mips
     echo "TARGET_ABI_MIPSN64=y" >> $config_target_mak
+    target_nptl="yes"
     target_phys_bits=64
     target_long_alignment=8
   ;;
diff -rupN qemu-1.0.1/cpu-exec.c modified_QEMU/cpu-exec.c
--- qemu-1.0.1/cpu-exec.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/cpu-exec.c	2015-01-29 09:21:20.000000000 -0800
@@ -22,6 +22,44 @@
 #include "tcg.h"
 #include "qemu-barrier.h"
 
+
+static const char * const excp_names[EXCP_LAST + 1] = {
+    [EXCP_RESET] = "reset",
+    [EXCP_SRESET] = "soft reset",
+    [EXCP_DSS] = "debug single step",
+    [EXCP_DINT] = "debug interrupt",
+    [EXCP_NMI] = "non-maskable interrupt",
+    [EXCP_MCHECK] = "machine check",
+    [EXCP_EXT_INTERRUPT] = "interrupt",
+    [EXCP_DFWATCH] = "deferred watchpoint",
+    [EXCP_DIB] = "debug instruction breakpoint",
+    [EXCP_IWATCH] = "instruction fetch watchpoint",
+    [EXCP_AdEL] = "address error load",
+    [EXCP_AdES] = "address error store",
+    [EXCP_TLBF] = "TLB refill",
+    [EXCP_IBE] = "instruction bus error",
+    [EXCP_DBp] = "debug breakpoint",
+    [EXCP_SYSCALL] = "syscall",
+    [EXCP_BREAK] = "break",
+    [EXCP_CpU] = "coprocessor unusable",
+    [EXCP_RI] = "reserved instruction",
+    [EXCP_OVERFLOW] = "arithmetic overflow",
+    [EXCP_TRAP] = "trap",
+    [EXCP_FPE] = "floating point",
+    [EXCP_DDBS] = "debug data break store",
+    [EXCP_DWATCH] = "data watchpoint",
+    [EXCP_LTLBL] = "TLB modify",
+    [EXCP_TLBL] = "TLB load",
+    [EXCP_TLBS] = "TLB store",
+    [EXCP_DBE] = "data bus error",
+    [EXCP_DDBL] = "debug data break load",
+    [EXCP_THREAD] = "thread",
+    [EXCP_MDMX] = "MDMX",
+    [EXCP_C2E] = "precise coprocessor 2",
+    [EXCP_CACHE] = "cache error",
+};
+
+
 int tb_invalidated_flag;
 
 //#define CONFIG_DEBUG_EXEC
@@ -131,7 +169,6 @@ static TranslationBlock *tb_find_slow(CP
         tb_phys_hash[h] = tb;
     }
     /* we add the TB in the virtual pc hash table */
-    env->tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb;
     return tb;
 }
 
diff -rupN qemu-1.0.1/default-configs/mips64-linux-user.mak modified_QEMU/default-configs/mips64-linux-user.mak
--- qemu-1.0.1/default-configs/mips64-linux-user.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/default-configs/mips64-linux-user.mak	2015-01-29 09:21:22.000000000 -0800
@@ -0,0 +1 @@
+# Default configuration for mips64-linux-user
diff -rupN qemu-1.0.1/exec.c modified_QEMU/exec.c
--- qemu-1.0.1/exec.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/exec.c	2015-01-29 09:21:16.000000000 -0800
@@ -56,7 +56,7 @@
 #include "xen-mapcache.h"
 #include "trace.h"
 #endif
-
+extern CPUState * envArray[12];
 //#define DEBUG_TB_INVALIDATE
 //#define DEBUG_FLUSH
 //#define DEBUG_TLB
@@ -1648,7 +1648,7 @@ static void cpu_unlink_tb(CPUState *env)
 #ifndef CONFIG_USER_ONLY
 /* mask must never be zero, except for A20 change call */
 static void tcg_handle_interrupt(CPUState *env, int mask)
-{
+{     //  fprintf(stderr,"\n tcg_handle_interrupt \n");
     int old_mask;
 
     old_mask = env->interrupt_request;
@@ -1694,6 +1694,7 @@ void cpu_exit(CPUState *env)
 {
     env->exit_request = 1;
     cpu_unlink_tb(env);
+     envArray[0]->CP0_Cause &=0xFFFFFBFF;   //line added by ayaz
 }
 
 const CPULogItem cpu_log_items[] = {
diff -rupN qemu-1.0.1/.git/config modified_QEMU/.git/config
--- qemu-1.0.1/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/config	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = ssh://maryyam35@git.code.sf.net/p/smehost/code
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -rupN qemu-1.0.1/.git/description modified_QEMU/.git/description
--- qemu-1.0.1/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/description	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -rupN qemu-1.0.1/.git/HEAD modified_QEMU/.git/HEAD
--- qemu-1.0.1/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/HEAD	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -rupN qemu-1.0.1/.git/hooks/applypatch-msg.sample modified_QEMU/.git/hooks/applypatch-msg.sample
--- qemu-1.0.1/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/applypatch-msg.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -rupN qemu-1.0.1/.git/hooks/commit-msg.sample modified_QEMU/.git/hooks/commit-msg.sample
--- qemu-1.0.1/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/commit-msg.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -rupN qemu-1.0.1/.git/hooks/post-update.sample modified_QEMU/.git/hooks/post-update.sample
--- qemu-1.0.1/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/post-update.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -rupN qemu-1.0.1/.git/hooks/pre-applypatch.sample modified_QEMU/.git/hooks/pre-applypatch.sample
--- qemu-1.0.1/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/pre-applypatch.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -rupN qemu-1.0.1/.git/hooks/pre-commit.sample modified_QEMU/.git/hooks/pre-commit.sample
--- qemu-1.0.1/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/pre-commit.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -rupN qemu-1.0.1/.git/hooks/prepare-commit-msg.sample modified_QEMU/.git/hooks/prepare-commit-msg.sample
--- qemu-1.0.1/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/prepare-commit-msg.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -rupN qemu-1.0.1/.git/hooks/pre-push.sample modified_QEMU/.git/hooks/pre-push.sample
--- qemu-1.0.1/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/pre-push.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -rupN qemu-1.0.1/.git/hooks/pre-rebase.sample modified_QEMU/.git/hooks/pre-rebase.sample
--- qemu-1.0.1/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/pre-rebase.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -rupN qemu-1.0.1/.git/hooks/update.sample modified_QEMU/.git/hooks/update.sample
--- qemu-1.0.1/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/hooks/update.sample	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files qemu-1.0.1/.git/index and modified_QEMU/.git/index differ
diff -rupN qemu-1.0.1/.git/info/exclude modified_QEMU/.git/info/exclude
--- qemu-1.0.1/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/info/exclude	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -rupN qemu-1.0.1/.git/logs/HEAD modified_QEMU/.git/logs/HEAD
--- qemu-1.0.1/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/logs/HEAD	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 38a738c335de70a7a94d73dc70d70945af6da201 root <root@server2.(none)> 1413790874 +0500	clone: from ssh://maryyam35@git.code.sf.net/p/smehost/code
diff -rupN qemu-1.0.1/.git/logs/refs/heads/master modified_QEMU/.git/logs/refs/heads/master
--- qemu-1.0.1/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/logs/refs/heads/master	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 38a738c335de70a7a94d73dc70d70945af6da201 root <root@server2.(none)> 1413790874 +0500	clone: from ssh://maryyam35@git.code.sf.net/p/smehost/code
diff -rupN qemu-1.0.1/.git/logs/refs/remotes/origin/HEAD modified_QEMU/.git/logs/refs/remotes/origin/HEAD
--- qemu-1.0.1/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/logs/refs/remotes/origin/HEAD	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 38a738c335de70a7a94d73dc70d70945af6da201 root <root@server2.(none)> 1413790874 +0500	clone: from ssh://maryyam35@git.code.sf.net/p/smehost/code
Binary files qemu-1.0.1/.git/objects/pack/pack-d14d6354c2c35d43b41cd4d661f083c9c5bda4e3.idx and modified_QEMU/.git/objects/pack/pack-d14d6354c2c35d43b41cd4d661f083c9c5bda4e3.idx differ
Binary files qemu-1.0.1/.git/objects/pack/pack-d14d6354c2c35d43b41cd4d661f083c9c5bda4e3.pack and modified_QEMU/.git/objects/pack/pack-d14d6354c2c35d43b41cd4d661f083c9c5bda4e3.pack differ
diff -rupN qemu-1.0.1/.git/packed-refs modified_QEMU/.git/packed-refs
--- qemu-1.0.1/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/packed-refs	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled 
+38a738c335de70a7a94d73dc70d70945af6da201 refs/remotes/origin/master
diff -rupN qemu-1.0.1/.git/refs/heads/master modified_QEMU/.git/refs/heads/master
--- qemu-1.0.1/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/refs/heads/master	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1 @@
+38a738c335de70a7a94d73dc70d70945af6da201
diff -rupN qemu-1.0.1/.git/refs/remotes/origin/HEAD modified_QEMU/.git/refs/remotes/origin/HEAD
--- qemu-1.0.1/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/.git/refs/remotes/origin/HEAD	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -rupN qemu-1.0.1/.gitignore modified_QEMU/.gitignore
--- qemu-1.0.1/.gitignore	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/.gitignore	2015-01-29 09:21:14.000000000 -0800
@@ -76,3 +76,7 @@ cscope.*
 tags
 TAGS
 *~
+#following two files were made after doing configuration, so ignored.
+roms/seabios/config.mak
+roms/vgabios/config.mak
+
diff -rupN qemu-1.0.1/hw/e1000.c modified_QEMU/hw/e1000.c
--- qemu-1.0.1/hw/e1000.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/hw/e1000.c	2015-01-29 09:21:18.000000000 -0800
@@ -23,8 +23,8 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
-
-
+int DELL=0;
+extern int ayaz2;
 #include "hw.h"
 #include "pci.h"
 #include "net.h"
@@ -32,11 +32,10 @@
 #include "loader.h"
 #include "sysemu.h"
 #include "dma.h"
-
 #include "e1000_hw.h"
 
 #define E1000_DEBUG
-
+//int glob_e1000_int=0;
 #ifdef E1000_DEBUG
 enum {
     DEBUG_GENERAL,	DEBUG_IO,	DEBUG_MMIO,	DEBUG_INTERRUPT,
@@ -58,7 +57,7 @@ static int debugflags = DBGBIT(TXERR) |
 #define IOPORT_SIZE       0x40
 #define PNPMMIO_SIZE      0x20000
 #define MIN_BUF_SIZE      60 /* Min. octets in an ethernet frame sans FCS */
-
+int tmp_chck=0;
 /*
  * HW models:
  *  E1000_DEV_ID_82540EM works with Windows and Linux
@@ -126,7 +125,7 @@ typedef struct E1000State_st {
         uint32_t old_eecd;
     } eecd_state;
 } E1000State;
-
+E1000State *d;
 #define	defreg(x)	x = (E1000_##x>>2)
 enum {
     defreg(CTRL),	defreg(EECD),	defreg(EERD),	defreg(GPRC),
@@ -155,19 +154,30 @@ static const char phy_regcap[0x20] = {
 static void
 set_interrupt_cause(E1000State *s, int index, uint32_t val)
 {
+	//glob_e1000_int=1;
+//fprintf(stderr,"si");
+	 //fprintf(stderr,"\n ****** S.I.C val=0x%llx \n",val);
+	// printf("\n Raising e1000 interrupt \n");
+    
     if (val)
         val |= E1000_ICR_INT_ASSERTED;
     s->mac_reg[ICR] = val;
     s->mac_reg[ICS] = val;
+      //            printf("\n val in S.I.C:0x%llx \n",val);
+   // fprintf(stderr,"\n IMS=0x%llx \n",s->mac_reg[IMS]);
+   // fprintf(stderr,"\n sset int cause:%d \n",(s->mac_reg[IMS] & s->mac_reg[ICR]) != 0);
     qemu_set_irq(s->dev.irq[0], (s->mac_reg[IMS] & s->mac_reg[ICR]) != 0);
 }
 
 static void
 set_ics(E1000State *s, int index, uint32_t val)
-{
+{   uint32 tmp_val;
     DBGOUT(INTERRUPT, "set_ics %x, ICR %x, IMR %x\n", val, s->mac_reg[ICR],
         s->mac_reg[IMS]);
-    set_interrupt_cause(s, 0, val | s->mac_reg[ICR]);
+  //  fprintf(stderr,"\n set_ics:0x%llx",val | s->mac_reg[ICR]);
+
+    	set_interrupt_cause(s, 0, val | s->mac_reg[ICR]);
+
 }
 
 static int
@@ -236,26 +246,61 @@ set_mdic(E1000State *s, int index, uint3
     s->mac_reg[MDIC] = val | E1000_MDIC_READY;
     set_ics(s, 0, E1000_ICR_MDAC);
 }
-
-static uint32_t
+E1000State *test_pointer;
+//static
+ uint32_t
 get_eecd(E1000State *s, int index)
-{
-    uint32_t ret = E1000_EECD_PRES|E1000_EECD_GNT | s->eecd_state.old_eecd;
+{   //printf("\n eeprom priniting in get_eecd \n");
+      //test_pointer=s;
+	 //int j;
+	 //for (j=0; j<64; j++){
+     //if(j>7 && j%8==0)
+       //printf("\n");
+       //printf(" 0x%llx ",s->eeprom_data[j]);	
+       	
+	//}
+	
+	
+	
+		//printf("\n eecd_state.val_in=0x%llx \n",s->eecd_state.val_in);
+	//printf("\n eecd_state.bitnum_in=0x%llx \n",s->eecd_state.bitnum_in);
+	//printf("\n eecd_state.bitnum_out=0x%llx \n",s->eecd_state.bitnum_out);
+	//printf("\n eecd_state.reading=0x%llx \n",s->eecd_state.reading);
+	//printf("\n eecd_state.old_eecd=0x%llx \n",s->eecd_state.old_eecd);
 
+
+    uint32_t ret = E1000_EECD_PRES|E1000_EECD_GNT | s->eecd_state.old_eecd;
+    //  printf("\n eecd is called >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  \n");
     DBGOUT(EEPROM, "reading eeprom bit %d (reading %d)\n",
            s->eecd_state.bitnum_out, s->eecd_state.reading);
+          //printf("\n reading eeprom bit %d (reading %d)\n",
+          //s->eecd_state.bitnum_out, s->eecd_state.reading);
+         // printf("s->eeprom_data[(s->eecd_state.bitnum_out >> 4) & 0x3f]:0x%llx \n",s->eeprom_data[(s->eecd_state.bitnum_out >> 4) & 0x3f]);
+         // printf("\n ((s->eecd_state.bitnum_out & 0xf) ^ 0xf))) :0x%llx \n",((s->eecd_state.bitnum_out & 0xf) ^ 0xf));
     if (!s->eecd_state.reading ||
-        ((s->eeprom_data[(s->eecd_state.bitnum_out >> 4) & 0x3f] >>
-          ((s->eecd_state.bitnum_out & 0xf) ^ 0xf))) & 1)
-        ret |= E1000_EECD_DO;
+        (((s->eeprom_data[(s->eecd_state.bitnum_out >> 4) & 0x3f] >>
+          ((s->eecd_state.bitnum_out & 0xf) ^ 0xf))) & 1))
+        ret |= E1000_EECD_DO;      
+    //printf("\n eecd:returnv value:0x%llx \n",ret);
     return ret;
 }
 
-static void
+//static 
+void
 set_eecd(E1000State *s, int index, uint32_t val)
-{
+{   
+	//s=test_pointer;
+	//printf("\n  set_eecd is called: val:0x%llx  \n",val);
     uint32_t oldval = s->eecd_state.old_eecd;
-
+     //printf("\n eeprom priniting in set_eecd \n");
+    //int j;
+	 //for (j=0; j<64; j++){
+      //if(j>7 && j%8==0)
+       //printf("\n");
+       //printf(" 0x%llx ",s->eeprom_data[j]);	
+       	//}//
+	
+   
     s->eecd_state.old_eecd = val & (E1000_EECD_SK | E1000_EECD_CS |
             E1000_EECD_DI|E1000_EECD_FWE_MASK|E1000_EECD_REQ);
     if (!(E1000_EECD_CS & val))			// CS inactive; nothing to do
@@ -283,6 +328,9 @@ set_eecd(E1000State *s, int index, uint3
     DBGOUT(EEPROM, "eeprom bitnum in %d out %d, reading %d\n",
            s->eecd_state.bitnum_in, s->eecd_state.bitnum_out,
            s->eecd_state.reading);
+          // printf("\n eeprom bitnum in %d out %d, reading %d\n",s->eecd_state.bitnum_in, s->eecd_state.bitnum_out,
+          // s->eecd_state.reading);
+           
 }
 
 static uint32_t
@@ -524,12 +572,12 @@ static uint64_t tx_desc_base(E1000State
 
 static void
 start_xmit(E1000State *s)
-{
+{ //  printf(	"\n In start_xmit \n");
     dma_addr_t base;
     struct e1000_tx_desc desc;
     uint32_t tdh_start = s->mac_reg[TDH], cause = E1000_ICS_TXQE;
-
-    if (!(s->mac_reg[TCTL] & E1000_TCTL_EN)) {
+  
+    if (!(s->mac_reg[TCTL] & E1000_TCTL_EN)) {// printf("\n tx disabled \n");
         DBGOUT(TX, "tx disabled\n");
         return;
     }
@@ -537,12 +585,14 @@ start_xmit(E1000State *s)
     while (s->mac_reg[TDH] != s->mac_reg[TDT]) {
         base = tx_desc_base(s) +
                sizeof(struct e1000_tx_desc) * s->mac_reg[TDH];
+              // printf("\n going to call pci_dma_read ........\n");
+       // fprintf(stderr,"check in start_xmit");
         pci_dma_read(&s->dev, base, (void *)&desc, sizeof(desc));
 
         DBGOUT(TX, "index %d: %p : %x %x\n", s->mac_reg[TDH],
                (void *)(intptr_t)desc.buffer_addr, desc.lower.data,
                desc.upper.data);
-
+           // fprintf(stderr,"check in start_xmit");
         process_tx_desc(s, &desc);
         cause |= txdesc_writeback(s, base, &desc);
 
@@ -564,7 +614,7 @@ start_xmit(E1000State *s)
 
 static int
 receive_filter(E1000State *s, const uint8_t *buf, int size)
-{
+{  //   fprintf(stderr,"\n receive_filter \n");
     static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
     static const int mta_shift[] = {4, 3, 2, 0};
     uint32_t f, rctl = s->mac_reg[RCTL], ra[2], *rp;
@@ -617,7 +667,7 @@ receive_filter(E1000State *s, const uint
 
 static void
 e1000_set_link_status(VLANClientState *nc)
-{
+{   //   fprintf(stderr,"e1000_set_link_status");
     E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
     uint32_t old_status = s->mac_reg[STATUS];
 
@@ -634,7 +684,7 @@ e1000_set_link_status(VLANClientState *n
 }
 
 static bool e1000_has_rxbufs(E1000State *s, size_t total_size)
-{
+{   
     int bufs;
     /* Fast-path short packets */
     if (total_size <= s->rxbuf_size) {
@@ -653,7 +703,7 @@ static bool e1000_has_rxbufs(E1000State
 
 static int
 e1000_can_receive(VLANClientState *nc)
-{
+{   
     E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
 
     return (s->mac_reg[RCTL] & E1000_RCTL_EN) && e1000_has_rxbufs(s, 1);
@@ -669,7 +719,11 @@ static uint64_t rx_desc_base(E1000State
 
 static ssize_t
 e1000_receive(VLANClientState *nc, const uint8_t *buf, size_t size)
-{
+{  // fprintf(stderr,"\n e1000 receive packet \n");
+	/*if(tmp_chck)
+		tmp_chck=0;
+	else
+		tmp_chck=1;*/
     E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
     struct e1000_rx_desc desc;
     dma_addr_t base;
@@ -726,10 +780,13 @@ e1000_receive(VLANClientState *nc, const
                 if (copy_size > s->rxbuf_size) {
                     copy_size = s->rxbuf_size;
                 }
+              //  fprintf(stderr,	"\n pci dma write \n");
                 pci_dma_write(&s->dev, le64_to_cpu(desc.buffer_addr),
                                  (void *)(buf + desc_offset + vlan_offset),
                                  copy_size);
+              //  fprintf(stderr,	"\n pci dma write 2 \n");
             }
+          //  fprintf(stderr,	"\n pci dma write 3 \n");
             desc_offset += desc_size;
             desc.length = cpu_to_le16(desc_size);
             if (desc_offset >= total_size) {
@@ -751,6 +808,7 @@ e1000_receive(VLANClientState *nc, const
         if (s->mac_reg[RDH] == rdh_start) {
             DBGOUT(RXERR, "RDH wraparound @%x, RDT %x, RDLEN %x\n",
                    rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);
+          //  fprintf(stderr,"\set_ics in e1000_receive 1 \n");
             set_ics(s, 0, E1000_ICS_RXO);
             return -1;
         }
@@ -773,7 +831,11 @@ e1000_receive(VLANClientState *nc, const
     if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>
         s->rxbuf_min_shift)
         n |= E1000_ICS_RXDMT0;
-
+  // fprintf(stderr,"\set_ics in e1000_receive 2;n=0x%llx \n",n);
+  /* if(tmp_chck)
+   s->mac_reg[IMS]=0x0;
+   else
+	   s->mac_reg[IMS]=0x9d;*/
     set_ics(s, 0, n);
 
     return size;
@@ -781,15 +843,18 @@ e1000_receive(VLANClientState *nc, const
 
 static uint32_t
 mac_readreg(E1000State *s, int index)
-{
+{  // printf("\n ------------------mac_readreg-------------------: index:%d \n",index);
+   // printf("\n **********************s->mac_reg:0x%llx**********\n",s->mac_reg[index]);	
+   // printf("\n s:0x%llx \n",s);
     return s->mac_reg[index];
 }
 
 static uint32_t
 mac_icr_read(E1000State *s, int index)
-{
+{  // printf("\n QEMU mac read \n");
+    //  printf("\n s:0x%llx \n",s);
     uint32_t ret = s->mac_reg[ICR];
-
+     // fprintf(stderr,"ICR 0x%llx ", ret);
     DBGOUT(INTERRUPT, "ICR read: %x\n", ret);
     set_interrupt_cause(s, 0, 0);
     return ret;
@@ -797,7 +862,7 @@ mac_icr_read(E1000State *s, int index)
 
 static uint32_t
 mac_read_clr4(E1000State *s, int index)
-{
+{    //printf("\n QEMU mac read \n");
     uint32_t ret = s->mac_reg[index];
 
     s->mac_reg[index] = 0;
@@ -806,7 +871,7 @@ mac_read_clr4(E1000State *s, int index)
 
 static uint32_t
 mac_read_clr8(E1000State *s, int index)
-{
+{  // printf("\n QEMU mac read \n");
     uint32_t ret = s->mac_reg[index];
 
     s->mac_reg[index] = 0;
@@ -816,7 +881,7 @@ mac_read_clr8(E1000State *s, int index)
 
 static void
 mac_writereg(E1000State *s, int index, uint32_t val)
-{
+{   // printf("\n mac_writereg: and s=%d  \n",s);
     s->mac_reg[index] = val;
 }
 
@@ -851,12 +916,13 @@ static void
 set_icr(E1000State *s, int index, uint32_t val)
 {
     DBGOUT(INTERRUPT, "set_icr %x\n", val);
+   // fprintf(stderr,"\n set_icr:0x%llx",val);
     set_interrupt_cause(s, 0, s->mac_reg[ICR] & ~val);
 }
 
 static void
 set_imc(E1000State *s, int index, uint32_t val)
-{
+{  // fprintf("\n ")
     s->mac_reg[IMS] &= ~val;
     set_ics(s, 0, 0);
 }
@@ -904,16 +970,19 @@ static void (*macreg_writeops[])(E1000St
 };
 enum { NWRITEOPS = ARRAY_SIZE(macreg_writeops) };
 
-static void
+void
 e1000_mmio_write(void *opaque, target_phys_addr_t addr, uint64_t val,
                  unsigned size)
-{
-    E1000State *s = opaque;
+{ // ayaz2=0;
+    E1000State *s = d;//opaque;
+    //s=test_pointer;
+   // fprintf(stderr,"\n:e1000:mmio_write:val=0x%llx",val);
     unsigned int index = (addr & 0x1ffff) >> 2;
-
+        //   printf("\n ((( e1000_mmio_write:\n");
     if (index < NWRITEOPS && macreg_writeops[index]) {
+        // printf("\n ----e1000_mmio_write\n");
         macreg_writeops[index](s, index, val);
-    } else if (index < NREADOPS && macreg_readops[index]) {
+        } else if (index < NREADOPS && macreg_readops[index]) {
         DBGOUT(MMIO, "e1000_mmio_writel RO %x: 0x%04"PRIx64"\n", index<<2, val);
     } else {
         DBGOUT(UNKNOWN, "MMIO unknown write addr=0x%08x,val=0x%08"PRIx64"\n",
@@ -921,12 +990,66 @@ e1000_mmio_write(void *opaque, target_ph
     }
 }
 
-static uint64_t
+uint64_t
 e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)
-{
-    E1000State *s = opaque;
-    unsigned int index = (addr & 0x1ffff) >> 2;
+{ // printf("\n e1000_mmio_read \n");
+   // printf("\n opaque in e1000_mmio_read : 0x%llx \n",opaque);
+E1000State *s = d;//opaque;
+
+int i;
+//test_pointer=s;   
+ if(DELL == 0  && 0){
+	 uint16_t e1000_eeprom_template[64] = {
+    0x5452, 0x1200, 0x5634, 0x0000,      0xffff, 0x0000,      0x0000, 0x0000,
+    0x3000, 0x1000, 0x6403, E1000_DEVID, 0x8086, E1000_DEVID, 0x8086, 0x3040,
+    0x0008, 0x2000, 0x7e14, 0x0048,      0x1000, 0x00d8,      0x0000, 0x2700,
+    0x6cc9, 0x3150, 0x0722, 0x040b,      0x0984, 0x0000,      0xc000, 0x0706,
+    0x1008, 0x0000, 0x0f04, 0x7fff,      0x4d01, 0xffff,      0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff,      0xffff, 0xffff,      0xffff, 0xffff,
+    0x0100, 0x4000, 0x121c, 0xffff,      0xffff, 0xffff,      0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff,      0xffff, 0xffff,      0xffff, 0x79ad,
+};
+	 uint8_t *macaddr;
+	 uint8_t *pci_conf;
+	  memmove(s->eeprom_data,e1000_eeprom_template,
+        sizeof e1000_eeprom_template);
+    //qemu_macaddr_default_if_unset(&s->conf.macaddr);
+    //macaddr = s->conf.macaddr.a;
+    //for (i = 0; i < 3; i++)
+        //s->eeprom_data[i] = (macaddr[2*i+1]<<8) | macaddr[2*i];
+         s->eecd_state.val_in=0x0; 
+         s->eecd_state.bitnum_in=0x0; 
+         s->eecd_state.bitnum_out=0x0; 
+         s->eecd_state.reading=0x0;
+         s->eecd_state.old_eecd=0x0; 
+        
+         pci_conf = s->dev.config;
+ //printf("\n _______________\\\\\\\\\\\\\\\\\\\\\HOST PCI \\\\\\\\\\\\\\\___________________ \n");
+    /* TODO: RST# value should be 0, PCI spec 6.2.4 */
+    pci_conf[PCI_CACHE_LINE_SIZE] = 0x10;
+    pci_conf[PCI_INTERRUPT_PIN] = 1; /* interrupt pin A */
+    printf("\n pci bar0 e1000: 0x%llx \n",pci_conf[0x10]);
+    printf("\n pci bar1 e1000: 0x%llx \n",pci_conf[0x14]);
+  //  pci_conf[PCI_BASE_ADDRESS_1]=0x80011A001fbf0000;  //0xffffffffbf000000;
+    //e1000_mmio_setup(s);
+ //printf("\n PCI_BASE_ADDRESS_SPACE_MEMORY:0x%llx \n",&s->mmio.addr);
+ //printf("\n  PCI_BASE_ADDRESS_SPACE_I0 :0x%llx  \n",PCI_BASE_ADDRESS_SPACE_IO);
+ //printf("\n PCI VENDOR ID : =x%llx \n",pci_conf[0x0]);
+    pci_register_bar(&s->dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->mmio);
+    pci_register_bar(&s->dev, 1, PCI_BASE_ADDRESS_SPACE_IO, &s->io);
+   //s->nic = qemu_new_nic(&net_e1000_info, &s->conf,
+     //                     s->dev.qdev.info->name, s->dev.qdev.id, s);
 
+    //qemu_format_nic_info_str(&s->nic->nc, macaddr);
+
+    //add_boot_device_path(s->conf.bootindex, &pci_dev->qdev, "/ethernet-phy@0");
+        
+        
+	 DELL=1;
+ }
+   // printf("\n ****** s=0x%llx \n",s);
+    unsigned int index = (addr & 0x1ffff) >> 2;
+     //printf("\n index=0x%llx and NREADOPS:0x%llx\n",index,NREADOPS);
     if (index < NREADOPS && macreg_readops[index])
     {
         return macreg_readops[index](s, index);
@@ -957,8 +1080,8 @@ static uint64_t e1000_io_read(void *opaq
 static void e1000_io_write(void *opaque, target_phys_addr_t addr,
                            uint64_t val, unsigned size)
 {
-    E1000State *s = opaque;
-
+   E1000State *s = opaque;
+   
     (void)s;
 }
 
@@ -1051,7 +1174,8 @@ static const VMStateDescription vmstate_
     }
 };
 
-static const uint16_t e1000_eeprom_template[64] = {
+//static const 
+uint16_t e1000_eeprom_template[64] = {
     0x0000, 0x0000, 0x0000, 0x0000,      0xffff, 0x0000,      0x0000, 0x0000,
     0x3000, 0x1000, 0x6403, E1000_DEVID, 0x8086, E1000_DEVID, 0x8086, 0x3040,
     0x0008, 0x2000, 0x7e14, 0x0048,      0x1000, 0x00d8,      0x0000, 0x2700,
@@ -1095,9 +1219,10 @@ e1000_mmio_setup(E1000State *d)
         E1000_MDIC, E1000_ICR, E1000_ICS, E1000_IMS,
         E1000_IMC, E1000_TCTL, E1000_TDT, PNPMMIO_SIZE
     };
-
+    MemoryRegion *e1000_mmio_add_space = get_system_memory();
     memory_region_init_io(&d->mmio, &e1000_mmio_ops, d, "e1000-mmio",
                           PNPMMIO_SIZE);
+    //memory_region_add_subregion(e1000_mmio_add_space,0xffffffffbf000000,&d->mmio);                      
     memory_region_add_coalescing(&d->mmio, 0, excluded_regs[0]);
     for (i = 0; excluded_regs[i] != PNPMMIO_SIZE; i++)
         memory_region_add_coalescing(&d->mmio, excluded_regs[i] + 4,
@@ -1127,7 +1252,6 @@ pci_e1000_uninit(PCIDevice *dev)
 static void e1000_reset(void *opaque)
 {
     E1000State *d = opaque;
-
     memset(d->phy_reg, 0, sizeof d->phy_reg);
     memmove(d->phy_reg, phy_reg_init, sizeof phy_reg_init);
     memset(d->mac_reg, 0, sizeof d->mac_reg);
@@ -1145,14 +1269,16 @@ static NetClientInfo net_e1000_info = {
     .link_status_changed = e1000_set_link_status,
 };
 
-static int pci_e1000_init(PCIDevice *pci_dev)
+//static
+ int pci_e1000_init(PCIDevice *pci_dev)
 {
-    E1000State *d = DO_UPCAST(E1000State, dev, pci_dev);
+    //E1000State *d 
+    d= DO_UPCAST(E1000State, dev, pci_dev);
+
     uint8_t *pci_conf;
     uint16_t checksum = 0;
     int i;
     uint8_t *macaddr;
-
     pci_conf = d->dev.config;
 
     /* TODO: RST# value should be 0, PCI spec 6.2.4 */
@@ -1163,9 +1289,8 @@ static int pci_e1000_init(PCIDevice *pci
     e1000_mmio_setup(d);
 
     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &d->mmio);
-
     pci_register_bar(&d->dev, 1, PCI_BASE_ADDRESS_SPACE_IO, &d->io);
-
+ 
     memmove(d->eeprom_data, e1000_eeprom_template,
         sizeof e1000_eeprom_template);
     qemu_macaddr_default_if_unset(&d->conf.macaddr);
@@ -1174,7 +1299,9 @@ static int pci_e1000_init(PCIDevice *pci
         d->eeprom_data[i] = (macaddr[2*i+1]<<8) | macaddr[2*i];
     for (i = 0; i < EEPROM_CHECKSUM_REG; i++)
         checksum += d->eeprom_data[i];
+
     checksum = (uint16_t) EEPROM_SUM - checksum;
+
     d->eeprom_data[EEPROM_CHECKSUM_REG] = checksum;
 
     d->nic = qemu_new_nic(&net_e1000_info, &d->conf,
diff -rupN qemu-1.0.1/hw/gt64xxx.c modified_QEMU/hw/gt64xxx.c
--- qemu-1.0.1/hw/gt64xxx.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/hw/gt64xxx.c	2015-01-29 09:21:18.000000000 -0800
@@ -28,7 +28,6 @@
 #include "pci_host.h"
 #include "pc.h"
 #include "exec-memory.h"
-
 //#define DEBUG
 
 #ifdef DEBUG
@@ -311,11 +310,12 @@ static void gt64120_writel (void *opaque
 {
     GT64120State *s = opaque;
     uint32_t saddr;
-
+//printf("\n gt write \n");
     if (!(s->regs[GT_CPU] & 0x00001000))
-        val = bswap32(val);
+     //   val = bswap32(val);
 
     saddr = (addr & 0xfff) >> 2;
+  //  printf("\n saddr; 0x%llx \n",saddr);
     switch (saddr) {
 
     /* CPU Configuration */
@@ -530,12 +530,13 @@ static void gt64120_writel (void *opaque
         /* not implemented */
         break;
     case GT_PCI0_CFGADDR:
-        s->pci.config_reg = val & 0x80fffffc;
+        s->pci.config_reg = val ; // & 0x80fffffc; //commented by ayaz
         break;
     case GT_PCI0_CFGDATA:
-        if (!(s->regs[GT_PCI0_CMD] & 1) && (s->pci.config_reg & 0x00fff800))
-            val = bswap32(val);
-        if (s->pci.config_reg & (1u << 31))
+      //  if (!(s->regs[GT_PCI0_CMD] & 1) && (s->pci.config_reg & 0x00fff800))
+          //  val = bswap32(val);
+    //    if (s->pci.config_reg & (1u << 31))  //commented by ayaz
+    //printf("\n pci write: val:0x%llx \n",val);
             pci_data_write(s->pci.bus, s->pci.config_reg, val, 4);
         break;
 
@@ -777,8 +778,9 @@ static uint64_t gt64120_readl (void *opa
             val = 0xffffffff;
         else
             val = pci_data_read(s->pci.bus, s->pci.config_reg, 4);
+          //  printf("\n ____________ valuer ead in gt64xxx = 0x%llx ________ \n",val);
         if (!(s->regs[GT_PCI0_CMD] & 1) && (s->pci.config_reg & 0x00fff800))
-            val = bswap32(val);
+           // val = bswap32(val);
         break;
 
     case GT_PCI0_CMD:
diff -rupN qemu-1.0.1/hw/i8254.c modified_QEMU/hw/i8254.c
--- qemu-1.0.1/hw/i8254.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/hw/i8254.c	2015-01-29 09:21:18.000000000 -0800
@@ -27,7 +27,7 @@
 #include "qemu-timer.h"
 
 //#define DEBUG_PIT
-
+int glob_pit_int=0;
 #define RW_STATE_LSB 1
 #define RW_STATE_MSB 2
 #define RW_STATE_WORD0 3
@@ -382,7 +382,9 @@ static void pit_irq_timer_update(PITChan
         return;
     expire_time = pit_get_next_transition_time(s, current_time);
     irq_level = pit_get_out1(s, current_time);
-    qemu_set_irq(s->irq, irq_level);
+   // fprintf(stderr,"\n pit_irq_timer_update \n");
+          glob_pit_int=1;
+    qemu_set_irq(s->irq, irq_level);  //commeneted by ayaz
 #ifdef DEBUG_PIT
     printf("irq_level=%d next_delay=%f\n",
            irq_level,
diff -rupN qemu-1.0.1/hw/i8259.c modified_QEMU/hw/i8259.c
--- qemu-1.0.1/hw/i8259.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/hw/i8259.c	2015-01-29 09:21:18.000000000 -0800
@@ -37,6 +37,7 @@
 #define DPRINTF(fmt, ...)
 #endif
 
+	#define DEBUG_IRQ_COUNT
 //#define DEBUG_IRQ_LATENCY
 //#define DEBUG_IRQ_COUNT
 
diff -rupN qemu-1.0.1/hw/mips_int.c modified_QEMU/hw/mips_int.c
--- qemu-1.0.1/hw/mips_int.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/hw/mips_int.c	2015-01-29 09:21:18.000000000 -0800
@@ -23,25 +23,40 @@
 #include "hw.h"
 #include "mips_cpudevs.h"
 #include "cpu.h"
-
+extern int glob_e1000_int;
+int just_var=500;
+extern int glob_timer_int;
 static void cpu_mips_irq_request(void *opaque, int irq, int level)
 {
     CPUState *env = (CPUState *)opaque;
 
     if (irq < 0 || irq > 7)
         return;
+        
+//printf("\n interrupt in cpu_mips_irq_request:%d \n",irq);
 
+  
     if (level) {
         env->CP0_Cause |= 1 << (irq + CP0Ca_IP);
     } else {
         env->CP0_Cause &= ~(1 << (irq + CP0Ca_IP));
     }
 
-    if (env->CP0_Cause & CP0Ca_IP_mask) {
-        cpu_interrupt(env, CPU_INTERRUPT_HARD);
-    } else {
+    
+    
+   //is if condition is added to make sure only uART's interrupt is passed on
+
+  if (env->CP0_Cause & CP0Ca_IP_mask){
+	  glob_timer_int=0;
+	// fprintf(stderr,"\n CP0_Cause:0x%llx and irq:%d \n",env->CP0_Cause,irq);
+	  cpu_interrupt(env, CPU_INTERRUPT_HARD);
+	  //	env->CP0_Cause &= 0xFFFFFBFF;
+    } else {  
         cpu_reset_interrupt(env, CPU_INTERRUPT_HARD);
     }
+    
+    
+    
 }
 
 void cpu_mips_irq_init_cpu(CPUState *env)
diff -rupN qemu-1.0.1/hw/mips_octeon.c modified_QEMU/hw/mips_octeon.c
--- qemu-1.0.1/hw/mips_octeon.c	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/hw/mips_octeon.c	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,482 @@
+/*
+ * QEMU/MIPS pseudo-board
+ *
+ * emulates a simple machine with ISA-like bus.
+ * ISA IO space mapped to the 0x14000000 (PHYS) and
+ * ISA memory at the 0x10000000 (PHYS, 16Mb in size).
+ * All peripherial devices are attached to this "bus" with
+ * the standard PC ISA addresses.
+*/
+
+#include "hw.h"
+#include "mips.h"
+#include "mips_cpudevs.h"
+#include "pc.h"
+#include "isa.h"
+#include "net.h"
+#include "sysemu.h"
+#include "boards.h"
+#include "flash.h"
+#include "qemu-log.h"
+#include "mips-bios.h"
+#include "ide.h"
+#include "loader.h"
+#include "elf.h"
+#include "mc146818rtc.h"
+#include "blockdev.h"
+#include "exec-memory.h"
+#include "pci.h"
+#include "sysbus.h"
+
+#define MAX_IDE_BUS 2
+int ayaz=0;
+int ayaz2=0;
+CPUState * envArray[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static const int ide_iobase[2] = { 0x1f0, 0x170 };
+static const int ide_iobase2[2] = { 0x3f6, 0x376 };
+static const int ide_irq[2] = { 14, 15 };
+static void cpu_request_exit(void *opaque, int irq, int level)  //added by ayaz on may 19
+{
+    CPUState *env = cpu_single_env;
+
+    if (env && level) {
+        cpu_exit(env);
+    }
+}
+
+static int mips_octeon_sysbus_device_init(SysBusDevice *sysbusdev)
+{
+    return 0;
+}
+
+typedef struct {
+    SysBusDevice busdev;
+    qemu_irq *i8259;
+} OcteonState;
+
+static SysBusDeviceInfo mips_octeon_device = {
+    .init = mips_octeon_sysbus_device_init,
+    .qdev.name  = "mips-octeon",
+    .qdev.size  = sizeof(OcteonState),
+    .qdev.props = (Property[]) {
+        DEFINE_PROP_END_OF_LIST(),
+    }
+};
+
+static void mips_octeon_device_init(void)
+{
+    sysbus_register_withprop(&mips_octeon_device);
+}
+
+device_init(mips_octeon_device_init);
+
+
+
+
+static int load_kernel_tailored(const char* kernelFile, MemoryRegion *ram);
+
+static ISADevice *pit; /* PIT i8254 */
+/* i8254 PIT is attached to the IRQ0 at PIC i8259 */
+
+static struct _loaderparams {
+    int ram_size;
+    const char *kernel_filename;
+    const char *kernel_cmdline;
+    const char *initrd_filename;
+} loaderparams;
+extern void
+e1000_mmio_write(void *opaque, target_phys_addr_t addr, uint64_t val,
+                 unsigned size);
+
+static void mips_qemu_write (void *opaque, target_phys_addr_t addr,
+                             uint64_t val, unsigned size)
+{  // printf("\n mips_qemu_write  ++++++++++++ : mqw:addr:0x%llx \n",addr);
+    if( 1 == ayaz2 )
+     e1000_mmio_write(&opaque,addr,val,size);
+    
+    else if ((addr & 0xffff) == 0 && val == 42)
+        qemu_system_reset_request ();
+    else if ((addr & 0xffff) == 4 && val == 42)
+        qemu_system_shutdown_request ();
+}
+extern uint64_t 
+e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size);
+
+static uint64_t mips_qemu_read (void *opaque, target_phys_addr_t addr,
+                                unsigned size)
+{   //printf("\n mqr: address:0x%llx  \n",addr);
+	if( 1 == ayaz )
+	return e1000_mmio_read(&opaque,addr,size);
+    else
+    {
+    return 0;  //commented by ayaz
+ }
+}
+
+static const MemoryRegionOps mips_qemu_ops = {
+    .read = mips_qemu_read,
+    .write = mips_qemu_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+
+/* Network support */
+static void network_init(void)
+{
+    int i;
+
+    for(i = 0; i < nb_nics; i++) {
+        NICInfo *nd = &nd_table[i];
+        const char *default_devaddr = NULL;
+
+        if (i == 0 && (!nd->model || strcmp(nd->model, "e1000") == 0))
+            /* The malta board has a PCNet card using PCI SLOT 11 */
+            default_devaddr = "0b";
+
+        pci_nic_init_nofail(nd, "e1000", default_devaddr);
+    }
+}
+
+
+typedef struct ResetData {
+    CPUState *env;
+    uint64_t vector;
+} ResetData;
+
+
+
+static void main_cpu_reset(void *opaque)
+{
+    ResetData *s = (ResetData *)opaque;
+    CPUState *env = s->env;
+
+    cpu_reset(env);
+    env->active_tc.PC = s->vector;
+}
+
+static const int sector_len = 32 * 1024;
+static
+void mips_r4k_init (ram_addr_t ram_size,
+                    const char *boot_device,
+                    const char *kernel_filename, const char *kernel_cmdline,
+                    const char *initrd_filename, const char *cpu_model)
+{
+  
+    char *filename;
+    MemoryRegion *address_space_mem = get_system_memory();
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+    MemoryRegion *ram1 = g_new(MemoryRegion, 1);
+    MemoryRegion *ram2 = g_new(MemoryRegion, 1);
+    MemoryRegion *cvmseg = g_new(MemoryRegion, 1);
+
+          
+    MemoryRegion *bios, *bios_alias,*kernel_load;//, *bios_octeon;
+    MemoryRegion *iomem = g_new(MemoryRegion, 1);
+
+    //.....................................................
+    PCIBus *pci_bus;
+    DeviceState *dev = qdev_create(NULL, "mips-octeon");
+    OcteonState *s = DO_UPCAST(OcteonState, busdev.qdev, dev);
+    int piix4_devfn;
+    //.....................................................
+
+    int bios_size;
+    CPUState *env;
+    ResetData *reset_info;
+    int i;
+    qemu_irq *i8259;
+    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
+    DriveInfo *dinfo;
+    int be;
+
+    /* init CPUs */
+    if (cpu_model == NULL) {
+#ifdef TARGET_MIPS64
+        cpu_model = "octeon";
+#else
+        cpu_model = "24Kf";
+#endif
+    }
+	   for (i = 0; i < smp_cpus; i++) {
+		env = cpu_init(cpu_model);
+		if (!env) {
+		fprintf(stderr, "Unable to find CPU definition\n");
+		exit(1);
+		}
+		reset_info = g_malloc0(sizeof(ResetData));
+		reset_info->env = env;
+		reset_info->vector = env->active_tc.PC;
+		cpu_mips_irq_init_cpu(env);
+		cpu_mips_clock_init(env);
+		qemu_register_reset(main_cpu_reset, reset_info);
+		envArray[i]=env; //store env pointer in array to access in softmmu_template.h file: smp issue
+		}
+	env = first_cpu;
+
+////************The following is the most important region*********************************************************
+ 
+
+     memory_region_init_ram(ram, NULL, "DR0 DRAM", 0x010000000ULL);
+        memory_region_add_subregion(address_space_mem, 0x0ULL, ram);
+
+ 
+        memory_region_init_ram(ram1, NULL, "DR1 DRAM", 0x010000000ULL);
+        memory_region_add_subregion(address_space_mem, 0x410000000ULL, ram1);
+
+        memory_region_init_ram(ram2, NULL, "DR2 DRAM", 0x020000000ULL);
+        memory_region_add_subregion(address_space_mem, 0x020000000ULL, ram2);
+   
+        memory_region_init_ram(cvmseg, NULL, "cvm segment", 0x1FFFULL);
+        memory_region_add_subregion(address_space_mem,0x510000000ULL , cvmseg);
+
+
+
+    memory_region_init_io(iomem, &mips_qemu_ops, NULL, "mips-qemu", 0x10000);
+    memory_region_add_subregion(address_space_mem, 0x1fbf0000, iomem);
+    
+
+    // printf("\n address space mem:%d \n",pci_bus->address_space_mem);
+     //printf("\n address space io:%d \n",pci_bus->address_space_io);
+     
+     
+   /* Try to load a BIOS image. If this fails, we continue regardless,
+       but initialize the hardware ourselves. When a kernel gets
+       preloaded we also initialize the hardware, since the BIOS wasn't
+       run. */
+    if (bios_name == NULL)
+        bios_name = BIOS_FILENAME;
+    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
+    if (filename) {
+        bios_size = get_image_size(filename);
+    } else {
+        bios_size = -1;
+    }
+#ifdef TARGET_WORDS_BIGENDIAN
+    be = 1;
+#else
+    be = 0;
+#endif
+    if ((bios_size > 0) && (bios_size <= BIOS_SIZE)) {
+        fprintf(stderr, "running bios");
+        bios = g_new(MemoryRegion, 1);
+        bios_alias = g_new(MemoryRegion, 1);
+
+
+        memory_region_init_ram(bios, NULL, "mips_r4k.bios", BIOS_SIZE);
+        memory_region_init_ram(bios_alias, NULL, "bios.1fc", BIOS_SIZE);
+
+
+        memory_region_set_readonly(bios, true);
+        memory_region_add_subregion(get_system_memory(), 0x1e000000LL, bios);
+        memory_region_add_subregion(get_system_memory(), 0x1fc00000LL, bios_alias);
+
+
+        load_image_targphys(filename, 0x1e000000, BIOS_SIZE);
+
+        load_image_targphys(filename, 0x1fc00000, BIOS_SIZE);
+
+
+        if(kernel_filename)
+        {
+        int64_t k_size=get_image_size(kernel_filename);
+
+        kernel_load= g_new(MemoryRegion, 1);
+        memory_region_init_ram(kernel_load, NULL, "kernel_load", k_size);
+        memory_region_add_subregion(get_system_memory(),0x10000000,kernel_load);
+        uint64_t *exp_base = memory_region_get_ram_ptr(kernel_load);
+    uint64_t r = bswap64(k_size);
+        memcpy(exp_base,&r,sizeof(r));
+
+      load_kernel_tailored(kernel_filename, ram);
+
+
+}
+        else
+            fprintf(stderr,"\nNo kernel file found to be loaded\n");
+            //load_image_targphys(filename, 0x100001fc00000, BIOS_SIZE);
+    } else if ((dinfo = drive_get(IF_PFLASH, 0, 0)) != NULL) {
+        uint32_t mips_rom = 0x00400000;
+        if (!pflash_cfi01_register(0x1fc00000, NULL, "mips_r4k.bios", mips_rom,
+                                   dinfo->bdrv, sector_len,
+                                   mips_rom / sector_len,
+                                   4, 0, 0, 0, 0, be)) {
+            fprintf(stderr, "qemu: Error registering flash memory.\n");
+    }
+    }
+    else {
+    /* not fatal */
+        fprintf(stderr, "qemu: Warning, could not load MIPS bios '%s'\n",
+        bios_name);
+    }
+    if (filename) {
+        g_free(filename);
+    }
+
+    if (kernel_filename) {
+        int64_t entry_bin;
+        MemoryRegion *enter = g_new(MemoryRegion, 1);
+        memory_region_init_ram(enter, NULL, "entry.boot", sizeof(entry_bin));
+           memory_region_add_subregion(address_space_mem, 0x1a000000LL, enter);
+
+uint64_t *base_entry = memory_region_get_ram_ptr(enter);
+
+        loaderparams.ram_size = ram_size;
+        loaderparams.kernel_filename = kernel_filename;
+        loaderparams.kernel_cmdline = kernel_cmdline;
+        loaderparams.initrd_filename = initrd_filename;
+
+        entry_bin= bswap64(entry_bin);
+        memcpy(base_entry,&entry_bin,sizeof(entry_bin));
+
+    // Following code is added to write CIU at appropriate place
+ 	MemoryRegion *ciu = g_new(MemoryRegion, 1);
+	memory_region_init_ram(ciu, NULL, "CIU",0x900ULL );
+	memory_region_add_subregion(address_space_mem, 0x0001070000000000ULL, ciu);
+   
+   /* int64_t ciu_fuse;
+        MemoryRegion *ciu_fuse_mem_reg = g_new(MemoryRegion, 1);
+        memory_region_init_ram(ciu_fuse_mem_reg, NULL, "ciu_fuse", sizeof(ciu_fuse));
+
+        memory_region_add_subregion(address_space_mem, 0x0001070000000728ULL, ciu_fuse_mem_reg);
+    ciu_fuse = 0x1; */
+
+ }   
+   /* Init CPU internal devices */
+    cpu_mips_irq_init_cpu(env);
+    cpu_mips_clock_init(env);
+
+    //...................AQ
+    qemu_irq *isa_irq;
+    isa_irq = qemu_irq_proxy(&s->i8259, 16);
+
+    /* Northbridge */
+    pci_bus = gt64120_register(isa_irq);
+
+    /* Southbridge */
+    ide_drive_get(hd, MAX_IDE_BUS);
+
+    piix4_devfn = piix4_init(pci_bus, 80);
+
+    s->i8259 = i8259_init(env->irq[2]);
+    isa_bus_irqs(s->i8259);
+
+    //pci_piix4_ide_init(pci_bus, hd, piix4_devfn+1);
+    pit = pit_init(0x40, 0);
+     
+    //...................
+
+    /* The PIC is attached to the MIPS CPU INT0 pin */
+    ////isa_bus_new(NULL, get_system_io());
+    ////i8259 = i8259_init(env->irq[2]);
+    ////isa_bus_irqs(i8259);
+
+    ////rtc_init(2000, NULL);
+      fprintf(stderr,"\n network_init() will be called now \n");
+    network_init();  //added by ayaz 
+         qemu_irq *cpu_exit_irq;
+   cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);  //added by ayaz on 19 may
+   // DMA_init(0, cpu_exit_irq);  //added by ayaz on 19 may
+
+    /* Register 64 KB of ISA IO space at 0x14000000 */
+    ////isa_mmio_init(0x14000000, 0x00010000);//this is what is required by qemu serial stuff
+    isa_mmio_init(0x18000000, 0x00010000);//this is what is required by qemu serial stuff   //changed by ayaz
+  // isa_mmio_init(0x1180000000800, 0x00010000);// this is what required by our octeon kernel
+ //    as a hack we have put both here
+ //   isa_mmio_init(0x1be00cf8, 0x00010000);  //added by ayaz
+   ////pit = pit_init(0x40, 0);
+
+    for(i = 0; i < MAX_SERIAL_PORTS; i++) {
+        if (serial_hds[i]) {
+            serial_isa_init(i, serial_hds[i]);
+        }
+    }
+
+    //isa_vga_init();
+
+    //if (nd_table[0].vlan)
+       // isa_ne2000_init(0x300, 9, &nd_table[0]);
+
+    ide_drive_get(hd, MAX_IDE_BUS);
+    for(i = 0; i < MAX_IDE_BUS; i++)
+        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],
+                     hd[MAX_IDE_DEVS * i],
+             hd[MAX_IDE_DEVS * i + 1]);
+
+    isa_create_simple("i8042");
+}
+
+static QEMUMachine mips_machine = {
+    .name = "octeon",
+    .desc = "mips r4k platform",
+    .init = mips_r4k_init,
+    .max_cpus = 16,
+};
+
+static void mips_machine_init(void)
+{
+    qemu_register_machine(&mips_machine);
+  
+}
+
+
+
+machine_init(mips_machine_init);
+
+ 
+
+
+// Code added by AQ on Nov 3, 2012
+
+static int load_kernel_tailored(const char* kernelFile, MemoryRegion *ram)
+{
+    int rfd = -1, wfd = -1;
+    int kernelFileSize = 0;
+    uint8_t *rBuffer = NULL;
+    int rc = 0; // read counter
+    //1. Open kernel file and find its size
+
+
+    rfd = open(kernelFile, O_RDONLY|O_BINARY|O_LARGEFILE);
+    if (rfd == -1)
+    {
+        fprintf(stderr, "\n Failed to open Kernel file %s .", kernelFile);
+        goto err;
+    }
+
+    kernelFileSize = lseek(rfd, 0, SEEK_END);
+
+
+    rBuffer = malloc(kernelFileSize);
+    if(NULL == rBuffer)
+    {
+        fprintf(stderr, "\n Failed to allocate memory for read buffer.");
+        goto err;
+    }
+    lseek(rfd, 0, SEEK_SET);
+
+    rc = read(rfd, rBuffer, kernelFileSize);
+
+    if(rc != kernelFileSize)
+    {
+        fprintf(stderr, "\n Failed to read sufficient bytes from the Kernel file.");
+        goto err;
+
+    }
+
+
+    //2. Copy data in guest memory
+
+    rom_add_blob("kernel", rBuffer, kernelFileSize,0x00800000);
+
+
+
+
+    return 0;
+
+    err:
+        if(-1 != rfd) close(rfd);
+        if(NULL != rBuffer) free(rBuffer);
+        if (-1 != wfd) close(wfd);
+        return -1;
+}
+
diff -rupN qemu-1.0.1/hw/mips_timer.c modified_QEMU/hw/mips_timer.c
--- qemu-1.0.1/hw/mips_timer.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/hw/mips_timer.c	2015-01-29 09:21:18.000000000 -0800
@@ -23,9 +23,9 @@
 #include "hw.h"
 #include "mips_cpudevs.h"
 #include "qemu-timer.h"
-
+int counter_timer_irq=0;
 #define TIMER_FREQ	100 * 1000 * 1000
-
+int glob_timer_int=0;
 /* XXX: do not use a global */
 uint32_t cpu_mips_get_random (CPUState *env)
 {
@@ -61,8 +61,16 @@ static void cpu_mips_timer_expire(CPUSta
     if (env->insn_flags & ISA_MIPS32R2) {
         env->CP0_Cause |= 1 << CP0Ca_TI;
     }
-    qemu_irq_raise(env->irq[(env->CP0_IntCtl >> CP0IntCtl_IPTI) & 0x7]);
-}
+  // fprintf(stderr,"\n timer_expeire_irq:%d \n");
+    glob_timer_int=1;
+   // if(counter_timer_irq < 1)
+   // counter_timer_irq++;
+     // printf("\n timer:irq:%d \n",counter_timer_irq);
+    //else{
+   // counter_timer_irq=0;
+    	qemu_irq_raise(env->irq[(env->CP0_IntCtl >> CP0IntCtl_IPTI) & 0x7]);  //commented by aya
+    //}
+    }
 
 uint32_t cpu_mips_get_count (CPUState *env)
 {
diff -rupN qemu-1.0.1/hw/pci.c modified_QEMU/hw/pci.c
--- qemu-1.0.1/hw/pci.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/hw/pci.c	2015-01-29 09:21:18.000000000 -0800
@@ -31,7 +31,7 @@
 #include "loader.h"
 #include "range.h"
 #include "qmp-commands.h"
-
+int glob_e1000_int=0;
 //#define DEBUG_PCI
 #ifdef DEBUG_PCI
 # define PCI_DPRINTF(format, ...)       printf(format, ## __VA_ARGS__)
@@ -136,7 +136,7 @@ int pci_bus_get_irq_level(PCIBus *bus, i
 /* Update interrupt status bit in config space on interrupt
  * state change. */
 static void pci_update_irq_status(PCIDevice *dev)
-{
+{      // fprintf(stderr,"\n interrupt stat. change in pci.c");
     if (dev->irq_state) {
         dev->config[PCI_STATUS] |= PCI_STATUS_INTERRUPT;
     } else {
@@ -1025,17 +1025,16 @@ static void pci_update_irq_disabled(PCID
 
 uint32_t pci_default_read_config(PCIDevice *d,
                                  uint32_t address, int len)
-{
-    uint32_t val = 0;
-
+{ int just_a=0;
+    uint32_t val = 0; 
     memcpy(&val, d->config + address, len);
+    last:
     return le32_to_cpu(val);
 }
 
 void pci_default_write_config(PCIDevice *d, uint32_t addr, uint32_t val, int l)
 {
     int i, was_irq_disabled = pci_irq_disabled(d);
-
     for (i = 0; i < l; val >>= 8, ++i) {
         uint8_t wmask = d->wmask[addr + i];
         uint8_t w1cmask = d->w1cmask[addr + i];
@@ -1061,15 +1060,16 @@ static void pci_set_irq(void *opaque, in
 {
     PCIDevice *pci_dev = opaque;
     int change;
-
+  //   fprintf(stderr,"\n pci set irq 1 \n");
     change = level - pci_irq_state(pci_dev, irq_num);
     if (!change)
         return;
-
+    glob_e1000_int=1;
     pci_set_irq_state(pci_dev, irq_num, level);
     pci_update_irq_status(pci_dev);
-    if (pci_irq_disabled(pci_dev))
-        return;
+   // if (pci_irq_disabled(pci_dev))
+     //  return;
+   // fprintf(stderr,"\n pci_irq");//commenetd by ayaz
     pci_change_irq_level(pci_dev, irq_num, change);
 }
 
diff -rupN qemu-1.0.1/hw/serial.c modified_QEMU/hw/serial.c
--- qemu-1.0.1/hw/serial.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/hw/serial.c	2015-01-29 09:21:18.000000000 -0800
@@ -30,7 +30,7 @@
 #include "sysemu.h"
 
 //#define DEBUG_SERIAL
-
+int glob_uart_int;
 #define UART_LCR_DLAB	0x80	/* Divisor latch access bit */
 
 #define UART_IER_MSI	0x08	/* Enable Modem status interrupt */
@@ -235,10 +235,10 @@ static void serial_update_irq(SerialStat
 
     s->iir = tmp_iir | (s->iir & 0xF0);
 
-    if (tmp_iir != UART_IIR_NO_INT) {
-        qemu_irq_raise(s->irq);
+    if (tmp_iir != UART_IIR_NO_INT) { glob_uart_int=1;
+			//qemu_irq_raise(s->irq);
     } else {
-        qemu_irq_lower(s->irq);
+        //qemu_irq_lower(s->irq);
     }
 }
 
diff -rupN qemu-1.0.1/libdis/config.mak modified_QEMU/libdis/config.mak
--- qemu-1.0.1/libdis/config.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libdis/config.mak	2015-02-11 23:03:06.963966000 -0800
@@ -0,0 +1,3 @@
+
+CONFIG_I386_DIS=y
+CONFIG_MIPS_DIS=y
diff -rupN qemu-1.0.1/libdis/Makefile modified_QEMU/libdis/Makefile
--- qemu-1.0.1/libdis/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libdis/Makefile	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,23 @@
+# Makefile for disassemblers.
+
+include ../config-host.mak
+include config.mak
+include $(SRC_PATH)/rules.mak
+
+.PHONY: all
+
+$(call set-vpath, $(SRC_PATH))
+
+QEMU_CFLAGS+=-I..
+
+include $(SRC_PATH)/Makefile.objs
+
+all: $(libdis-y)
+# Dummy command so that make thinks it has done something
+	@true
+
+clean:
+	rm -f *.o *.d *.a *~
+
+# Include automatically generated dependency files
+-include $(wildcard *.d */*.d)
diff -rupN qemu-1.0.1/libdis-user/config.mak modified_QEMU/libdis-user/config.mak
--- qemu-1.0.1/libdis-user/config.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libdis-user/config.mak	2015-02-11 23:03:06.915966000 -0800
@@ -0,0 +1 @@
+
diff -rupN qemu-1.0.1/libdis-user/Makefile modified_QEMU/libdis-user/Makefile
--- qemu-1.0.1/libdis-user/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libdis-user/Makefile	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,23 @@
+# Makefile for disassemblers.
+
+include ../config-host.mak
+include config.mak
+include $(SRC_PATH)/rules.mak
+
+.PHONY: all
+
+$(call set-vpath, $(SRC_PATH))
+
+QEMU_CFLAGS+=-I..
+
+include $(SRC_PATH)/Makefile.objs
+
+all: $(libdis-y)
+# Dummy command so that make thinks it has done something
+	@true
+
+clean:
+	rm -f *.o *.d *.a *~
+
+# Include automatically generated dependency files
+-include $(wildcard *.d */*.d)
diff -rupN qemu-1.0.1/libhw32/config.mak modified_QEMU/libhw32/config.mak
--- qemu-1.0.1/libhw32/config.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libhw32/config.mak	2015-02-11 23:03:07.101967000 -0800
@@ -0,0 +1 @@
+QEMU_CFLAGS+=-DTARGET_PHYS_ADDR_BITS=32
diff -rupN qemu-1.0.1/libhw32/Makefile modified_QEMU/libhw32/Makefile
--- qemu-1.0.1/libhw32/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libhw32/Makefile	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,25 @@
+# Makefile for qemu target independent devices.
+
+include ../config-host.mak
+include ../config-all-devices.mak
+include config.mak
+include $(SRC_PATH)/rules.mak
+
+.PHONY: all
+
+$(call set-vpath, $(SRC_PATH):$(SRC_PATH)/hw)
+
+QEMU_CFLAGS+=-I..
+QEMU_CFLAGS += $(GLIB_CFLAGS)
+
+include $(SRC_PATH)/Makefile.objs
+
+all: $(hw-obj-y)
+# Dummy command so that make thinks it has done something
+	@true
+
+clean:
+	rm -f *.o */*.o *.d */*.d *.a */*.a *~ */*~
+
+# Include automatically generated dependency files
+-include $(wildcard *.d */*.d)
diff -rupN qemu-1.0.1/libhw64/config.mak modified_QEMU/libhw64/config.mak
--- qemu-1.0.1/libhw64/config.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libhw64/config.mak	2015-02-11 23:03:07.119967000 -0800
@@ -0,0 +1 @@
+QEMU_CFLAGS+=-DTARGET_PHYS_ADDR_BITS=64
diff -rupN qemu-1.0.1/libhw64/Makefile modified_QEMU/libhw64/Makefile
--- qemu-1.0.1/libhw64/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libhw64/Makefile	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,25 @@
+# Makefile for qemu target independent devices.
+
+include ../config-host.mak
+include ../config-all-devices.mak
+include config.mak
+include $(SRC_PATH)/rules.mak
+
+.PHONY: all
+
+$(call set-vpath, $(SRC_PATH):$(SRC_PATH)/hw)
+
+QEMU_CFLAGS+=-I..
+QEMU_CFLAGS += $(GLIB_CFLAGS)
+
+include $(SRC_PATH)/Makefile.objs
+
+all: $(hw-obj-y)
+# Dummy command so that make thinks it has done something
+	@true
+
+clean:
+	rm -f *.o */*.o *.d */*.d *.a */*.a *~ */*~
+
+# Include automatically generated dependency files
+-include $(wildcard *.d */*.d)
diff -rupN qemu-1.0.1/libuser/Makefile modified_QEMU/libuser/Makefile
--- qemu-1.0.1/libuser/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/libuser/Makefile	2015-01-29 09:21:18.000000000 -0800
@@ -0,0 +1,25 @@
+# Makefile for qemu target independent user files.
+
+include ../config-host.mak
+include $(SRC_PATH)/rules.mak
+-include config.mak
+
+.PHONY: all
+
+$(call set-vpath, $(SRC_PATH))
+
+QEMU_CFLAGS+=-I..
+
+include $(SRC_PATH)/Makefile.objs
+
+all: $(user-obj-y)
+# Dummy command so that make thinks it has done something
+	@true
+
+clean:
+	for d in . trace; do \
+	rm -f $$d/*.o $$d/*.d $$d/*.a $$d/*~; \
+	done
+
+# Include automatically generated dependency files
+-include $(wildcard *.d */*.d)
diff -rupN qemu-1.0.1/linux-headers/asm/hyperv.h modified_QEMU/linux-headers/asm/hyperv.h
--- qemu-1.0.1/linux-headers/asm/hyperv.h	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/linux-headers/asm/hyperv.h	2015-01-29 09:21:16.000000000 -0800
@@ -0,0 +1,193 @@
+#ifndef _ASM_X86_HYPERV_H
+#define _ASM_X86_HYPERV_H
+
+#include <linux/types.h>
+
+/*
+ * The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
+ * is set by CPUID(HvCpuIdFunctionVersionAndFeatures).
+ */
+#define HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS	0x40000000
+#define HYPERV_CPUID_INTERFACE			0x40000001
+#define HYPERV_CPUID_VERSION			0x40000002
+#define HYPERV_CPUID_FEATURES			0x40000003
+#define HYPERV_CPUID_ENLIGHTMENT_INFO		0x40000004
+#define HYPERV_CPUID_IMPLEMENT_LIMITS		0x40000005
+
+#define HYPERV_HYPERVISOR_PRESENT_BIT		0x80000000
+#define HYPERV_CPUID_MIN			0x40000005
+#define HYPERV_CPUID_MAX			0x4000ffff
+
+/*
+ * Feature identification. EAX indicates which features are available
+ * to the partition based upon the current partition privileges.
+ */
+
+/* VP Runtime (HV_X64_MSR_VP_RUNTIME) available */
+#define HV_X64_MSR_VP_RUNTIME_AVAILABLE		(1 << 0)
+/* Partition Reference Counter (HV_X64_MSR_TIME_REF_COUNT) available*/
+#define HV_X64_MSR_TIME_REF_COUNT_AVAILABLE	(1 << 1)
+/*
+ * Basic SynIC MSRs (HV_X64_MSR_SCONTROL through HV_X64_MSR_EOM
+ * and HV_X64_MSR_SINT0 through HV_X64_MSR_SINT15) available
+ */
+#define HV_X64_MSR_SYNIC_AVAILABLE		(1 << 2)
+/*
+ * Synthetic Timer MSRs (HV_X64_MSR_STIMER0_CONFIG through
+ * HV_X64_MSR_STIMER3_COUNT) available
+ */
+#define HV_X64_MSR_SYNTIMER_AVAILABLE		(1 << 3)
+/*
+ * APIC access MSRs (HV_X64_MSR_EOI, HV_X64_MSR_ICR and HV_X64_MSR_TPR)
+ * are available
+ */
+#define HV_X64_MSR_APIC_ACCESS_AVAILABLE	(1 << 4)
+/* Hypercall MSRs (HV_X64_MSR_GUEST_OS_ID and HV_X64_MSR_HYPERCALL) available*/
+#define HV_X64_MSR_HYPERCALL_AVAILABLE		(1 << 5)
+/* Access virtual processor index MSR (HV_X64_MSR_VP_INDEX) available*/
+#define HV_X64_MSR_VP_INDEX_AVAILABLE		(1 << 6)
+/* Virtual system reset MSR (HV_X64_MSR_RESET) is available*/
+#define HV_X64_MSR_RESET_AVAILABLE		(1 << 7)
+ /*
+  * Access statistics pages MSRs (HV_X64_MSR_STATS_PARTITION_RETAIL_PAGE,
+  * HV_X64_MSR_STATS_PARTITION_INTERNAL_PAGE, HV_X64_MSR_STATS_VP_RETAIL_PAGE,
+  * HV_X64_MSR_STATS_VP_INTERNAL_PAGE) available
+  */
+#define HV_X64_MSR_STAT_PAGES_AVAILABLE		(1 << 8)
+
+/*
+ * Feature identification: EBX indicates which flags were specified at
+ * partition creation. The format is the same as the partition creation
+ * flag structure defined in section Partition Creation Flags.
+ */
+#define HV_X64_CREATE_PARTITIONS		(1 << 0)
+#define HV_X64_ACCESS_PARTITION_ID		(1 << 1)
+#define HV_X64_ACCESS_MEMORY_POOL		(1 << 2)
+#define HV_X64_ADJUST_MESSAGE_BUFFERS		(1 << 3)
+#define HV_X64_POST_MESSAGES			(1 << 4)
+#define HV_X64_SIGNAL_EVENTS			(1 << 5)
+#define HV_X64_CREATE_PORT			(1 << 6)
+#define HV_X64_CONNECT_PORT			(1 << 7)
+#define HV_X64_ACCESS_STATS			(1 << 8)
+#define HV_X64_DEBUGGING			(1 << 11)
+#define HV_X64_CPU_POWER_MANAGEMENT		(1 << 12)
+#define HV_X64_CONFIGURE_PROFILER		(1 << 13)
+
+/*
+ * Feature identification. EDX indicates which miscellaneous features
+ * are available to the partition.
+ */
+/* The MWAIT instruction is available (per section MONITOR / MWAIT) */
+#define HV_X64_MWAIT_AVAILABLE				(1 << 0)
+/* Guest debugging support is available */
+#define HV_X64_GUEST_DEBUGGING_AVAILABLE		(1 << 1)
+/* Performance Monitor support is available*/
+#define HV_X64_PERF_MONITOR_AVAILABLE			(1 << 2)
+/* Support for physical CPU dynamic partitioning events is available*/
+#define HV_X64_CPU_DYNAMIC_PARTITIONING_AVAILABLE	(1 << 3)
+/*
+ * Support for passing hypercall input parameter block via XMM
+ * registers is available
+ */
+#define HV_X64_HYPERCALL_PARAMS_XMM_AVAILABLE		(1 << 4)
+/* Support for a virtual guest idle state is available */
+#define HV_X64_GUEST_IDLE_STATE_AVAILABLE		(1 << 5)
+
+/*
+ * Implementation recommendations. Indicates which behaviors the hypervisor
+ * recommends the OS implement for optimal performance.
+ */
+ /*
+  * Recommend using hypercall for address space switches rather
+  * than MOV to CR3 instruction
+  */
+#define HV_X64_MWAIT_RECOMMENDED		(1 << 0)
+/* Recommend using hypercall for local TLB flushes rather
+ * than INVLPG or MOV to CR3 instructions */
+#define HV_X64_LOCAL_TLB_FLUSH_RECOMMENDED	(1 << 1)
+/*
+ * Recommend using hypercall for remote TLB flushes rather
+ * than inter-processor interrupts
+ */
+#define HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED	(1 << 2)
+/*
+ * Recommend using MSRs for accessing APIC registers
+ * EOI, ICR and TPR rather than their memory-mapped counterparts
+ */
+#define HV_X64_APIC_ACCESS_RECOMMENDED		(1 << 3)
+/* Recommend using the hypervisor-provided MSR to initiate a system RESET */
+#define HV_X64_SYSTEM_RESET_RECOMMENDED		(1 << 4)
+/*
+ * Recommend using relaxed timing for this partition. If used,
+ * the VM should disable any watchdog timeouts that rely on the
+ * timely delivery of external interrupts
+ */
+#define HV_X64_RELAXED_TIMING_RECOMMENDED	(1 << 5)
+
+/* MSR used to identify the guest OS. */
+#define HV_X64_MSR_GUEST_OS_ID			0x40000000
+
+/* MSR used to setup pages used to communicate with the hypervisor. */
+#define HV_X64_MSR_HYPERCALL			0x40000001
+
+/* MSR used to provide vcpu index */
+#define HV_X64_MSR_VP_INDEX			0x40000002
+
+/* MSR used to read the per-partition time reference counter */
+#define HV_X64_MSR_TIME_REF_COUNT		0x40000020
+
+/* Define the virtual APIC registers */
+#define HV_X64_MSR_EOI				0x40000070
+#define HV_X64_MSR_ICR				0x40000071
+#define HV_X64_MSR_TPR				0x40000072
+#define HV_X64_MSR_APIC_ASSIST_PAGE		0x40000073
+
+/* Define synthetic interrupt controller model specific registers. */
+#define HV_X64_MSR_SCONTROL			0x40000080
+#define HV_X64_MSR_SVERSION			0x40000081
+#define HV_X64_MSR_SIEFP			0x40000082
+#define HV_X64_MSR_SIMP				0x40000083
+#define HV_X64_MSR_EOM				0x40000084
+#define HV_X64_MSR_SINT0			0x40000090
+#define HV_X64_MSR_SINT1			0x40000091
+#define HV_X64_MSR_SINT2			0x40000092
+#define HV_X64_MSR_SINT3			0x40000093
+#define HV_X64_MSR_SINT4			0x40000094
+#define HV_X64_MSR_SINT5			0x40000095
+#define HV_X64_MSR_SINT6			0x40000096
+#define HV_X64_MSR_SINT7			0x40000097
+#define HV_X64_MSR_SINT8			0x40000098
+#define HV_X64_MSR_SINT9			0x40000099
+#define HV_X64_MSR_SINT10			0x4000009A
+#define HV_X64_MSR_SINT11			0x4000009B
+#define HV_X64_MSR_SINT12			0x4000009C
+#define HV_X64_MSR_SINT13			0x4000009D
+#define HV_X64_MSR_SINT14			0x4000009E
+#define HV_X64_MSR_SINT15			0x4000009F
+
+
+#define HV_X64_MSR_HYPERCALL_ENABLE		0x00000001
+#define HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT	12
+#define HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_MASK	\
+		(~((1ull << HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT) - 1))
+
+/* Declare the various hypercall operations. */
+#define HV_X64_HV_NOTIFY_LONG_SPIN_WAIT		0x0008
+
+#define HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE		0x00000001
+#define HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT	12
+#define HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_MASK	\
+		(~((1ull << HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT) - 1))
+
+#define HV_PROCESSOR_POWER_STATE_C0		0
+#define HV_PROCESSOR_POWER_STATE_C1		1
+#define HV_PROCESSOR_POWER_STATE_C2		2
+#define HV_PROCESSOR_POWER_STATE_C3		3
+
+/* hypercall status code */
+#define HV_STATUS_SUCCESS			0
+#define HV_STATUS_INVALID_HYPERCALL_CODE	2
+#define HV_STATUS_INVALID_HYPERCALL_INPUT	3
+#define HV_STATUS_INVALID_ALIGNMENT		4
+
+#endif
diff -rupN qemu-1.0.1/linux-headers/asm/kvm.h modified_QEMU/linux-headers/asm/kvm.h
--- qemu-1.0.1/linux-headers/asm/kvm.h	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/linux-headers/asm/kvm.h	2015-01-29 09:21:16.000000000 -0800
@@ -0,0 +1,324 @@
+#ifndef _ASM_X86_KVM_H
+#define _ASM_X86_KVM_H
+
+/*
+ * KVM x86 specific structures and definitions
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+/* Select x86 specific features in <linux/kvm.h> */
+#define __KVM_HAVE_PIT
+#define __KVM_HAVE_IOAPIC
+#define __KVM_HAVE_DEVICE_ASSIGNMENT
+#define __KVM_HAVE_MSI
+#define __KVM_HAVE_USER_NMI
+#define __KVM_HAVE_GUEST_DEBUG
+#define __KVM_HAVE_MSIX
+#define __KVM_HAVE_MCE
+#define __KVM_HAVE_PIT_STATE2
+#define __KVM_HAVE_XEN_HVM
+#define __KVM_HAVE_VCPU_EVENTS
+#define __KVM_HAVE_DEBUGREGS
+#define __KVM_HAVE_XSAVE
+#define __KVM_HAVE_XCRS
+
+/* Architectural interrupt line count. */
+#define KVM_NR_INTERRUPTS 256
+
+struct kvm_memory_alias {
+	__u32 slot;  /* this has a different namespace than memory slots */
+	__u32 flags;
+	__u64 guest_phys_addr;
+	__u64 memory_size;
+	__u64 target_phys_addr;
+};
+
+/* for KVM_GET_IRQCHIP and KVM_SET_IRQCHIP */
+struct kvm_pic_state {
+	__u8 last_irr;	/* edge detection */
+	__u8 irr;		/* interrupt request register */
+	__u8 imr;		/* interrupt mask register */
+	__u8 isr;		/* interrupt service register */
+	__u8 priority_add;	/* highest irq priority */
+	__u8 irq_base;
+	__u8 read_reg_select;
+	__u8 poll;
+	__u8 special_mask;
+	__u8 init_state;
+	__u8 auto_eoi;
+	__u8 rotate_on_auto_eoi;
+	__u8 special_fully_nested_mode;
+	__u8 init4;		/* true if 4 byte init */
+	__u8 elcr;		/* PIIX edge/trigger selection */
+	__u8 elcr_mask;
+};
+
+#define KVM_IOAPIC_NUM_PINS  24
+struct kvm_ioapic_state {
+	__u64 base_address;
+	__u32 ioregsel;
+	__u32 id;
+	__u32 irr;
+	__u32 pad;
+	union {
+		__u64 bits;
+		struct {
+			__u8 vector;
+			__u8 delivery_mode:3;
+			__u8 dest_mode:1;
+			__u8 delivery_status:1;
+			__u8 polarity:1;
+			__u8 remote_irr:1;
+			__u8 trig_mode:1;
+			__u8 mask:1;
+			__u8 reserve:7;
+			__u8 reserved[4];
+			__u8 dest_id;
+		} fields;
+	} redirtbl[KVM_IOAPIC_NUM_PINS];
+};
+
+#define KVM_IRQCHIP_PIC_MASTER   0
+#define KVM_IRQCHIP_PIC_SLAVE    1
+#define KVM_IRQCHIP_IOAPIC       2
+#define KVM_NR_IRQCHIPS          3
+
+/* for KVM_GET_REGS and KVM_SET_REGS */
+struct kvm_regs {
+	/* out (KVM_GET_REGS) / in (KVM_SET_REGS) */
+	__u64 rax, rbx, rcx, rdx;
+	__u64 rsi, rdi, rsp, rbp;
+	__u64 r8,  r9,  r10, r11;
+	__u64 r12, r13, r14, r15;
+	__u64 rip, rflags;
+};
+
+/* for KVM_GET_LAPIC and KVM_SET_LAPIC */
+#define KVM_APIC_REG_SIZE 0x400
+struct kvm_lapic_state {
+	char regs[KVM_APIC_REG_SIZE];
+};
+
+struct kvm_segment {
+	__u64 base;
+	__u32 limit;
+	__u16 selector;
+	__u8  type;
+	__u8  present, dpl, db, s, l, g, avl;
+	__u8  unusable;
+	__u8  padding;
+};
+
+struct kvm_dtable {
+	__u64 base;
+	__u16 limit;
+	__u16 padding[3];
+};
+
+
+/* for KVM_GET_SREGS and KVM_SET_SREGS */
+struct kvm_sregs {
+	/* out (KVM_GET_SREGS) / in (KVM_SET_SREGS) */
+	struct kvm_segment cs, ds, es, fs, gs, ss;
+	struct kvm_segment tr, ldt;
+	struct kvm_dtable gdt, idt;
+	__u64 cr0, cr2, cr3, cr4, cr8;
+	__u64 efer;
+	__u64 apic_base;
+	__u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];
+};
+
+/* for KVM_GET_FPU and KVM_SET_FPU */
+struct kvm_fpu {
+	__u8  fpr[8][16];
+	__u16 fcw;
+	__u16 fsw;
+	__u8  ftwx;  /* in fxsave format */
+	__u8  pad1;
+	__u16 last_opcode;
+	__u64 last_ip;
+	__u64 last_dp;
+	__u8  xmm[16][16];
+	__u32 mxcsr;
+	__u32 pad2;
+};
+
+struct kvm_msr_entry {
+	__u32 index;
+	__u32 reserved;
+	__u64 data;
+};
+
+/* for KVM_GET_MSRS and KVM_SET_MSRS */
+struct kvm_msrs {
+	__u32 nmsrs; /* number of msrs in entries */
+	__u32 pad;
+
+	struct kvm_msr_entry entries[0];
+};
+
+/* for KVM_GET_MSR_INDEX_LIST */
+struct kvm_msr_list {
+	__u32 nmsrs; /* number of msrs in entries */
+	__u32 indices[0];
+};
+
+
+struct kvm_cpuid_entry {
+	__u32 function;
+	__u32 eax;
+	__u32 ebx;
+	__u32 ecx;
+	__u32 edx;
+	__u32 padding;
+};
+
+/* for KVM_SET_CPUID */
+struct kvm_cpuid {
+	__u32 nent;
+	__u32 padding;
+	struct kvm_cpuid_entry entries[0];
+};
+
+struct kvm_cpuid_entry2 {
+	__u32 function;
+	__u32 index;
+	__u32 flags;
+	__u32 eax;
+	__u32 ebx;
+	__u32 ecx;
+	__u32 edx;
+	__u32 padding[3];
+};
+
+#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX 1
+#define KVM_CPUID_FLAG_STATEFUL_FUNC    2
+#define KVM_CPUID_FLAG_STATE_READ_NEXT  4
+
+/* for KVM_SET_CPUID2 */
+struct kvm_cpuid2 {
+	__u32 nent;
+	__u32 padding;
+	struct kvm_cpuid_entry2 entries[0];
+};
+
+/* for KVM_GET_PIT and KVM_SET_PIT */
+struct kvm_pit_channel_state {
+	__u32 count; /* can be 65536 */
+	__u16 latched_count;
+	__u8 count_latched;
+	__u8 status_latched;
+	__u8 status;
+	__u8 read_state;
+	__u8 write_state;
+	__u8 write_latch;
+	__u8 rw_mode;
+	__u8 mode;
+	__u8 bcd;
+	__u8 gate;
+	__s64 count_load_time;
+};
+
+struct kvm_debug_exit_arch {
+	__u32 exception;
+	__u32 pad;
+	__u64 pc;
+	__u64 dr6;
+	__u64 dr7;
+};
+
+#define KVM_GUESTDBG_USE_SW_BP		0x00010000
+#define KVM_GUESTDBG_USE_HW_BP		0x00020000
+#define KVM_GUESTDBG_INJECT_DB		0x00040000
+#define KVM_GUESTDBG_INJECT_BP		0x00080000
+
+/* for KVM_SET_GUEST_DEBUG */
+struct kvm_guest_debug_arch {
+	__u64 debugreg[8];
+};
+
+struct kvm_pit_state {
+	struct kvm_pit_channel_state channels[3];
+};
+
+#define KVM_PIT_FLAGS_HPET_LEGACY  0x00000001
+
+struct kvm_pit_state2 {
+	struct kvm_pit_channel_state channels[3];
+	__u32 flags;
+	__u32 reserved[9];
+};
+
+struct kvm_reinject_control {
+	__u8 pit_reinject;
+	__u8 reserved[31];
+};
+
+/* When set in flags, include corresponding fields on KVM_SET_VCPU_EVENTS */
+#define KVM_VCPUEVENT_VALID_NMI_PENDING	0x00000001
+#define KVM_VCPUEVENT_VALID_SIPI_VECTOR	0x00000002
+#define KVM_VCPUEVENT_VALID_SHADOW	0x00000004
+
+/* Interrupt shadow states */
+#define KVM_X86_SHADOW_INT_MOV_SS	0x01
+#define KVM_X86_SHADOW_INT_STI		0x02
+
+/* for KVM_GET/SET_VCPU_EVENTS */
+struct kvm_vcpu_events {
+	struct {
+		__u8 injected;
+		__u8 nr;
+		__u8 has_error_code;
+		__u8 pad;
+		__u32 error_code;
+	} exception;
+	struct {
+		__u8 injected;
+		__u8 nr;
+		__u8 soft;
+		__u8 shadow;
+	} interrupt;
+	struct {
+		__u8 injected;
+		__u8 pending;
+		__u8 masked;
+		__u8 pad;
+	} nmi;
+	__u32 sipi_vector;
+	__u32 flags;
+	__u32 reserved[10];
+};
+
+/* for KVM_GET/SET_DEBUGREGS */
+struct kvm_debugregs {
+	__u64 db[4];
+	__u64 dr6;
+	__u64 dr7;
+	__u64 flags;
+	__u64 reserved[9];
+};
+
+/* for KVM_CAP_XSAVE */
+struct kvm_xsave {
+	__u32 region[1024];
+};
+
+#define KVM_MAX_XCRS	16
+
+struct kvm_xcr {
+	__u32 xcr;
+	__u32 reserved;
+	__u64 value;
+};
+
+struct kvm_xcrs {
+	__u32 nr_xcrs;
+	__u32 flags;
+	struct kvm_xcr xcrs[KVM_MAX_XCRS];
+	__u64 padding[16];
+};
+
+#endif /* _ASM_X86_KVM_H */
diff -rupN qemu-1.0.1/linux-headers/asm/kvm_para.h modified_QEMU/linux-headers/asm/kvm_para.h
--- qemu-1.0.1/linux-headers/asm/kvm_para.h	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/linux-headers/asm/kvm_para.h	2015-01-29 09:21:16.000000000 -0800
@@ -0,0 +1,93 @@
+#ifndef _ASM_X86_KVM_PARA_H
+#define _ASM_X86_KVM_PARA_H
+
+#include <linux/types.h>
+#include <asm/hyperv.h>
+
+/* This CPUID returns the signature 'KVMKVMKVM' in ebx, ecx, and edx.  It
+ * should be used to determine that a VM is running under KVM.
+ */
+#define KVM_CPUID_SIGNATURE	0x40000000
+
+/* This CPUID returns a feature bitmap in eax.  Before enabling a particular
+ * paravirtualization, the appropriate feature bit should be checked.
+ */
+#define KVM_CPUID_FEATURES	0x40000001
+#define KVM_FEATURE_CLOCKSOURCE		0
+#define KVM_FEATURE_NOP_IO_DELAY	1
+#define KVM_FEATURE_MMU_OP		2
+/* This indicates that the new set of kvmclock msrs
+ * are available. The use of 0x11 and 0x12 is deprecated
+ */
+#define KVM_FEATURE_CLOCKSOURCE2        3
+#define KVM_FEATURE_ASYNC_PF		4
+#define KVM_FEATURE_STEAL_TIME		5
+
+/* The last 8 bits are used to indicate how to interpret the flags field
+ * in pvclock structure. If no bits are set, all flags are ignored.
+ */
+#define KVM_FEATURE_CLOCKSOURCE_STABLE_BIT	24
+
+#define MSR_KVM_WALL_CLOCK  0x11
+#define MSR_KVM_SYSTEM_TIME 0x12
+
+#define KVM_MSR_ENABLED 1
+/* Custom MSRs falls in the range 0x4b564d00-0x4b564dff */
+#define MSR_KVM_WALL_CLOCK_NEW  0x4b564d00
+#define MSR_KVM_SYSTEM_TIME_NEW 0x4b564d01
+#define MSR_KVM_ASYNC_PF_EN 0x4b564d02
+#define MSR_KVM_STEAL_TIME  0x4b564d03
+
+struct kvm_steal_time {
+	__u64 steal;
+	__u32 version;
+	__u32 flags;
+	__u32 pad[12];
+};
+
+#define KVM_STEAL_ALIGNMENT_BITS 5
+#define KVM_STEAL_VALID_BITS ((-1ULL << (KVM_STEAL_ALIGNMENT_BITS + 1)))
+#define KVM_STEAL_RESERVED_MASK (((1 << KVM_STEAL_ALIGNMENT_BITS) - 1 ) << 1)
+
+#define KVM_MAX_MMU_OP_BATCH           32
+
+#define KVM_ASYNC_PF_ENABLED			(1 << 0)
+#define KVM_ASYNC_PF_SEND_ALWAYS		(1 << 1)
+
+/* Operations for KVM_HC_MMU_OP */
+#define KVM_MMU_OP_WRITE_PTE            1
+#define KVM_MMU_OP_FLUSH_TLB	        2
+#define KVM_MMU_OP_RELEASE_PT	        3
+
+/* Payload for KVM_HC_MMU_OP */
+struct kvm_mmu_op_header {
+	__u32 op;
+	__u32 pad;
+};
+
+struct kvm_mmu_op_write_pte {
+	struct kvm_mmu_op_header header;
+	__u64 pte_phys;
+	__u64 pte_val;
+};
+
+struct kvm_mmu_op_flush_tlb {
+	struct kvm_mmu_op_header header;
+};
+
+struct kvm_mmu_op_release_pt {
+	struct kvm_mmu_op_header header;
+	__u64 pt_phys;
+};
+
+#define KVM_PV_REASON_PAGE_NOT_PRESENT 1
+#define KVM_PV_REASON_PAGE_READY 2
+
+struct kvm_vcpu_pv_apf_data {
+	__u32 reason;
+	__u8 pad[60];
+	__u32 enabled;
+};
+
+
+#endif /* _ASM_X86_KVM_PARA_H */
diff -rupN qemu-1.0.1/Makefile modified_QEMU/Makefile
--- qemu-1.0.1/Makefile	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/Makefile	2015-01-29 09:21:18.000000000 -0800
@@ -34,7 +34,7 @@ configure: ;
 
 $(call set-vpath, $(SRC_PATH):$(SRC_PATH)/hw)
 
-LIBS+=-lz $(LIBS_TOOLS)
+LIBS+=-lz -lrt -lm  $(LIBS_TOOLS)
 
 ifdef BUILD_DOCS
 DOCS=qemu-doc.html qemu-tech.html qemu.1 qemu-img.1 qemu-nbd.8 QMP/qmp-commands.txt
@@ -355,19 +355,19 @@ qemu-img-cmds.texi: $(SRC_PATH)/qemu-img
 qemu.1: qemu-doc.texi qemu-options.texi qemu-monitor.texi
 	$(call quiet-command, \
 	  perl -Ww -- $(SRC_PATH)/scripts/texi2pod.pl $< qemu.pod && \
-	  pod2man --section=1 --center=" " --release=" " qemu.pod > $@, \
+	  pod2man --errors=none --section=1 --center=" " --release=" " qemu.pod > $@, \
 	  "  GEN   $@")
 
 qemu-img.1: qemu-img.texi qemu-img-cmds.texi
 	$(call quiet-command, \
 	  perl -Ww -- $(SRC_PATH)/scripts/texi2pod.pl $< qemu-img.pod && \
-	  pod2man --section=1 --center=" " --release=" " qemu-img.pod > $@, \
+	  pod2man --errors=none --section=1 --center=" " --release=" " qemu-img.pod > $@, \
 	  "  GEN   $@")
 
 qemu-nbd.8: qemu-nbd.texi
 	$(call quiet-command, \
 	  perl -Ww -- $(SRC_PATH)/scripts/texi2pod.pl $< qemu-nbd.pod && \
-	  pod2man --section=8 --center=" " --release=" " qemu-nbd.pod > $@, \
+	  pod2man --errors=none --section=8 --center=" " --release=" " qemu-nbd.pod > $@, \
 	  "  GEN   $@")
 
 dvi: qemu-doc.dvi qemu-tech.dvi
diff -rupN qemu-1.0.1/Makefile.target modified_QEMU/Makefile.target
--- qemu-1.0.1/Makefile.target	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/Makefile.target	2015-01-29 09:21:22.000000000 -0800
@@ -205,7 +205,7 @@ obj-$(CONFIG_REALLY_VIRTFS) += 9pfs/virt
 obj-$(CONFIG_KVM) += kvm.o kvm-all.o
 obj-$(CONFIG_NO_KVM) += kvm-stub.o
 obj-y += memory.o
-LIBS+=-lz
+LIBS+=-lz -lrt -lm
 
 QEMU_CFLAGS += $(VNC_TLS_CFLAGS)
 QEMU_CFLAGS += $(VNC_SASL_CFLAGS)
@@ -293,7 +293,7 @@ obj-lm32-y += milkymist-uart.o
 obj-lm32-y += milkymist-vgafb.o
 obj-lm32-y += framebuffer.o
 
-obj-mips-y = mips_r4k.o mips_jazz.o mips_malta.o mips_mipssim.o
+obj-mips-y = mips_r4k.o mips_jazz.o mips_malta.o mips_mipssim.o mips_octeon.o
 obj-mips-y += mips_addr.o mips_timer.o mips_int.o
 obj-mips-y += vga.o
 obj-mips-y += jazz_led.o
diff -rupN qemu-1.0.1/mips64-softmmu/config-devices.mak modified_QEMU/mips64-softmmu/config-devices.mak
--- qemu-1.0.1/mips64-softmmu/config-devices.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/mips64-softmmu/config-devices.mak	2015-02-11 23:03:10.590972000 -0800
@@ -0,0 +1,46 @@
+# Default configuration for mips64-softmmu
+
+CONFIG_ISA_MMIO=y
+CONFIG_ESP=y
+CONFIG_VGA_PCI=y
+CONFIG_VGA_ISA=y
+CONFIG_VGA_ISA_MM=y
+CONFIG_VMWARE_VGA=y
+CONFIG_SERIAL=y
+CONFIG_PARALLEL=y
+CONFIG_I8254=y
+CONFIG_PCSPK=y
+CONFIG_PCKBD=y
+CONFIG_FDC=y
+CONFIG_ACPI=y
+CONFIG_APM=y
+CONFIG_DMA=y
+CONFIG_PIIX4=y
+CONFIG_IDE_ISA=y
+CONFIG_IDE_PIIX=y
+CONFIG_NE2000_ISA=y
+CONFIG_SOUND=y
+CONFIG_RC4030=y
+CONFIG_DP8393X=y
+CONFIG_DS1225Y=y
+CONFIG_MIPSNET=y
+CONFIG_PFLASH_CFI01=y
+CONFIG_G364FB=y
+CONFIG_I8259=y
+CONFIG_PCI=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO=y
+CONFIG_USB_UHCI=y
+CONFIG_USB_OHCI=y
+CONFIG_USB_EHCI=y
+CONFIG_NE2000_PCI=y
+CONFIG_EEPRO100_PCI=y
+CONFIG_PCNET_PCI=y
+CONFIG_PCNET_COMMON=y
+CONFIG_LSI_SCSI_PCI=y
+CONFIG_RTL8139_PCI=y
+CONFIG_E1000_PCI=y
+CONFIG_IDE_CORE=y
+CONFIG_IDE_QDEV=y
+CONFIG_IDE_PCI=y
+CONFIG_AHCI=y
diff -rupN qemu-1.0.1/mips64-softmmu/config-devices.mak.old modified_QEMU/mips64-softmmu/config-devices.mak.old
--- qemu-1.0.1/mips64-softmmu/config-devices.mak.old	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/mips64-softmmu/config-devices.mak.old	2015-02-11 23:03:10.590972000 -0800
@@ -0,0 +1,46 @@
+# Default configuration for mips64-softmmu
+
+CONFIG_ISA_MMIO=y
+CONFIG_ESP=y
+CONFIG_VGA_PCI=y
+CONFIG_VGA_ISA=y
+CONFIG_VGA_ISA_MM=y
+CONFIG_VMWARE_VGA=y
+CONFIG_SERIAL=y
+CONFIG_PARALLEL=y
+CONFIG_I8254=y
+CONFIG_PCSPK=y
+CONFIG_PCKBD=y
+CONFIG_FDC=y
+CONFIG_ACPI=y
+CONFIG_APM=y
+CONFIG_DMA=y
+CONFIG_PIIX4=y
+CONFIG_IDE_ISA=y
+CONFIG_IDE_PIIX=y
+CONFIG_NE2000_ISA=y
+CONFIG_SOUND=y
+CONFIG_RC4030=y
+CONFIG_DP8393X=y
+CONFIG_DS1225Y=y
+CONFIG_MIPSNET=y
+CONFIG_PFLASH_CFI01=y
+CONFIG_G364FB=y
+CONFIG_I8259=y
+CONFIG_PCI=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO=y
+CONFIG_USB_UHCI=y
+CONFIG_USB_OHCI=y
+CONFIG_USB_EHCI=y
+CONFIG_NE2000_PCI=y
+CONFIG_EEPRO100_PCI=y
+CONFIG_PCNET_PCI=y
+CONFIG_PCNET_COMMON=y
+CONFIG_LSI_SCSI_PCI=y
+CONFIG_RTL8139_PCI=y
+CONFIG_E1000_PCI=y
+CONFIG_IDE_CORE=y
+CONFIG_IDE_QDEV=y
+CONFIG_IDE_PCI=y
+CONFIG_AHCI=y
diff -rupN qemu-1.0.1/mips64-softmmu/config-target.h modified_QEMU/mips64-softmmu/config-target.h
--- qemu-1.0.1/mips64-softmmu/config-target.h	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/mips64-softmmu/config-target.h	2015-01-29 09:21:16.000000000 -0800
@@ -0,0 +1,16 @@
+/* Automatically generated by create_config - do not modify */
+#define CONFIG_QEMU_INTERP_PREFIX "/usr/gnemul/qemu-mips64"
+#define TARGET_ABI_MIPSN64 1
+#define TARGET_SHORT_ALIGNMENT 2
+#define TARGET_INT_ALIGNMENT 4
+#define TARGET_LONG_ALIGNMENT 8
+#define TARGET_LLONG_ALIGNMENT 8
+#define TARGET_ARCH "mips64"
+#define TARGET_MIPS64 1
+#define TARGET_MIPS 1
+#define CONFIG_NO_XEN 1
+#define TARGET_WORDS_BIGENDIAN 1
+#define TARGET_PHYS_ADDR_BITS 64
+#define CONFIG_SOFTMMU 1
+#define CONFIG_I386_DIS 1
+#define CONFIG_MIPS_DIS 1
diff -rupN qemu-1.0.1/mips64-softmmu/config-target.h-timestamp modified_QEMU/mips64-softmmu/config-target.h-timestamp
--- qemu-1.0.1/mips64-softmmu/config-target.h-timestamp	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/mips64-softmmu/config-target.h-timestamp	2015-02-11 23:16:46.450204000 -0800
@@ -0,0 +1,16 @@
+/* Automatically generated by create_config - do not modify */
+#define CONFIG_QEMU_INTERP_PREFIX "/usr/gnemul/qemu-mips64"
+#define TARGET_ABI_MIPSN64 1
+#define TARGET_SHORT_ALIGNMENT 2
+#define TARGET_INT_ALIGNMENT 4
+#define TARGET_LONG_ALIGNMENT 8
+#define TARGET_LLONG_ALIGNMENT 8
+#define TARGET_ARCH "mips64"
+#define TARGET_MIPS64 1
+#define TARGET_MIPS 1
+#define CONFIG_NO_XEN 1
+#define TARGET_WORDS_BIGENDIAN 1
+#define TARGET_PHYS_ADDR_BITS 64
+#define CONFIG_SOFTMMU 1
+#define CONFIG_I386_DIS 1
+#define CONFIG_MIPS_DIS 1
diff -rupN qemu-1.0.1/mips64-softmmu/config-target.mak modified_QEMU/mips64-softmmu/config-target.mak
--- qemu-1.0.1/mips64-softmmu/config-target.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/mips64-softmmu/config-target.mak	2015-02-11 23:03:06.980966000 -0800
@@ -0,0 +1,23 @@
+# Automatically generated by configure - do not modify
+CONFIG_QEMU_INTERP_PREFIX="/usr/gnemul/qemu-mips64"
+TARGET_ABI_MIPSN64=y
+TARGET_SHORT_ALIGNMENT=2
+TARGET_INT_ALIGNMENT=4
+TARGET_LONG_ALIGNMENT=8
+TARGET_LLONG_ALIGNMENT=8
+TARGET_ARCH=mips64
+TARGET_MIPS64=y
+TARGET_ARCH2=mips64
+TARGET_BASE_ARCH=mips
+TARGET_ABI_DIR=mips64
+CONFIG_NO_XEN=y
+TARGET_WORDS_BIGENDIAN=y
+TARGET_PHYS_ADDR_BITS=64
+CONFIG_SOFTMMU=y
+LIBS+=-lutil   
+HWDIR=../libhw64
+CONFIG_I386_DIS=y
+CONFIG_MIPS_DIS=y
+LDFLAGS+=
+QEMU_CFLAGS+=-DHAS_AUDIO -DHAS_AUDIO_CHOICE 
+QEMU_INCLUDES+=-I$(SRC_PATH)/linux-headers -I$(SRC_PATH)/tcg -I$(SRC_PATH)/tcg/i386 
diff -rupN qemu-1.0.1/mips64-softmmu/Makefile modified_QEMU/mips64-softmmu/Makefile
--- qemu-1.0.1/mips64-softmmu/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/mips64-softmmu/Makefile	2015-01-29 09:21:22.000000000 -0800
@@ -0,0 +1,450 @@
+# -*- Mode: makefile -*-
+
+GENERATED_HEADERS = config-target.h
+CONFIG_NO_PCI = $(if $(subst n,,$(CONFIG_PCI)),n,y)
+CONFIG_NO_KVM = $(if $(subst n,,$(CONFIG_KVM)),n,y)
+CONFIG_NO_XEN = $(if $(subst n,,$(CONFIG_XEN)),n,y)
+
+include ../config-host.mak
+include config-devices.mak
+include config-target.mak
+include $(SRC_PATH)/rules.mak
+ifneq ($(HWDIR),)
+include $(HWDIR)/config.mak
+endif
+
+TARGET_PATH=$(SRC_PATH)/target-$(TARGET_BASE_ARCH)
+$(call set-vpath, $(SRC_PATH):$(TARGET_PATH):$(SRC_PATH)/hw)
+ifdef CONFIG_LINUX
+QEMU_CFLAGS += -I../linux-headers
+endif
+QEMU_CFLAGS += -I.. -I$(TARGET_PATH) -DNEED_CPU_H
+
+include $(SRC_PATH)/Makefile.objs
+
+ifdef CONFIG_USER_ONLY
+# user emulator name
+QEMU_PROG=qemu-$(TARGET_ARCH2)
+else
+# system emulator name
+QEMU_PROG=qemu-system-$(TARGET_ARCH2)$(EXESUF)
+endif
+
+PROGS=$(QEMU_PROG)
+STPFILES=
+
+ifndef CONFIG_HAIKU
+LIBS+=-lm
+endif
+
+config-target.h: config-target.h-timestamp
+config-target.h-timestamp: config-target.mak
+
+ifdef CONFIG_TRACE_SYSTEMTAP
+stap: $(QEMU_PROG).stp
+
+ifdef CONFIG_USER_ONLY
+TARGET_TYPE=user
+else
+TARGET_TYPE=system
+endif
+
+$(QEMU_PROG).stp:
+	$(call quiet-command,sh $(SRC_PATH)/scripts/tracetool \
+		--$(TRACE_BACKEND) \
+		--binary $(bindir)/$(QEMU_PROG) \
+		--target-arch $(TARGET_ARCH) \
+		--target-type $(TARGET_TYPE) \
+		--stap < $(SRC_PATH)/trace-events > $(QEMU_PROG).stp,"  GEN   $(QEMU_PROG).stp")
+else
+stap:
+endif
+
+all: $(PROGS) stap
+
+# Dummy command so that make thinks it has done something
+	@true
+
+#########################################################
+# cpu emulator library
+libobj-y = exec.o translate-all.o cpu-exec.o translate.o
+libobj-y += tcg/tcg.o tcg/optimize.o
+libobj-$(CONFIG_TCG_INTERPRETER) += tci.o
+libobj-y += fpu/softfloat.o
+libobj-y += op_helper.o helper.o
+ifeq ($(TARGET_BASE_ARCH), i386)
+libobj-y += cpuid.o
+endif
+libobj-$(TARGET_SPARC64) += vis_helper.o
+libobj-$(CONFIG_NEED_MMU) += mmu.o
+libobj-$(TARGET_ARM) += neon_helper.o iwmmxt_helper.o
+ifeq ($(TARGET_BASE_ARCH), sparc)
+libobj-y += fop_helper.o cc_helper.o win_helper.o mmu_helper.o ldst_helper.o
+libobj-y += cpu_init.o
+endif
+libobj-$(TARGET_SPARC) += int32_helper.o
+libobj-$(TARGET_SPARC64) += int64_helper.o
+
+libobj-y += disas.o
+libobj-$(CONFIG_TCI_DIS) += tci-dis.o
+
+tci-dis.o: QEMU_CFLAGS += -I$(SRC_PATH)/tcg -I$(SRC_PATH)/tcg/tci
+
+$(libobj-y): $(GENERATED_HEADERS)
+
+# libqemu
+
+translate.o: translate.c cpu.h
+
+translate-all.o: translate-all.c cpu.h
+
+tcg/tcg.o: cpu.h
+
+# HELPER_CFLAGS is used for all the code compiled with static register
+# variables
+op_helper.o ldst_helper.o user-exec.o: QEMU_CFLAGS += $(HELPER_CFLAGS)
+
+# Note: this is a workaround. The real fix is to avoid compiling
+# cpu_signal_handler() in user-exec.c.
+signal.o: QEMU_CFLAGS += $(HELPER_CFLAGS)
+
+#########################################################
+# Linux user emulator target
+
+ifdef CONFIG_LINUX_USER
+
+$(call set-vpath, $(SRC_PATH)/linux-user:$(SRC_PATH)/linux-user/$(TARGET_ABI_DIR))
+
+QEMU_CFLAGS+=-I$(SRC_PATH)/linux-user/$(TARGET_ABI_DIR) -I$(SRC_PATH)/linux-user
+obj-y = main.o syscall.o strace.o mmap.o signal.o thunk.o \
+      elfload.o linuxload.o uaccess.o gdbstub.o cpu-uname.o \
+      user-exec.o $(oslib-obj-y)
+
+obj-$(TARGET_HAS_BFLT) += flatload.o
+
+obj-$(TARGET_I386) += vm86.o
+
+obj-i386-y += ioport-user.o
+
+nwfpe-obj-y = fpa11.o fpa11_cpdo.o fpa11_cpdt.o fpa11_cprt.o fpopcode.o
+nwfpe-obj-y += single_cpdo.o double_cpdo.o extended_cpdo.o
+obj-arm-y +=  $(addprefix nwfpe/, $(nwfpe-obj-y))
+obj-arm-y += arm-semi.o
+
+obj-m68k-y += m68k-sim.o m68k-semi.o
+
+$(obj-y) $(obj-$(TARGET_BASE_ARCH)-y): $(GENERATED_HEADERS)
+
+obj-y += $(addprefix ../libuser/, $(user-obj-y))
+obj-y += $(addprefix ../libdis-user/, $(libdis-y))
+obj-y += $(libobj-y)
+
+endif #CONFIG_LINUX_USER
+
+#########################################################
+# Darwin user emulator target
+
+ifdef CONFIG_DARWIN_USER
+
+$(call set-vpath, $(SRC_PATH)/darwin-user)
+
+QEMU_CFLAGS+=-I$(SRC_PATH)/darwin-user -I$(SRC_PATH)/darwin-user/$(TARGET_ARCH)
+
+# Leave some space for the regular program loading zone
+LDFLAGS+=-Wl,-segaddr,__STD_PROG_ZONE,0x1000 -image_base 0x0e000000
+
+LIBS+=-lmx
+
+obj-y = main.o commpage.o machload.o mmap.o signal.o syscall.o thunk.o \
+        gdbstub.o user-exec.o
+
+obj-i386-y += ioport-user.o
+
+$(obj-y) $(obj-$(TARGET_BASE_ARCH)-y): $(GENERATED_HEADERS)
+
+obj-y += $(addprefix ../libuser/, $(user-obj-y))
+obj-y += $(addprefix ../libdis-user/, $(libdis-y))
+obj-y += $(libobj-y)
+
+endif #CONFIG_DARWIN_USER
+
+#########################################################
+# BSD user emulator target
+
+ifdef CONFIG_BSD_USER
+
+$(call set-vpath, $(SRC_PATH)/bsd-user)
+
+QEMU_CFLAGS+=-I$(SRC_PATH)/bsd-user -I$(SRC_PATH)/bsd-user/$(TARGET_ARCH)
+
+obj-y = main.o bsdload.o elfload.o mmap.o signal.o strace.o syscall.o \
+        gdbstub.o uaccess.o user-exec.o
+
+obj-i386-y += ioport-user.o
+
+$(obj-y) $(obj-$(TARGET_BASE_ARCH)-y): $(GENERATED_HEADERS)
+
+obj-y += $(addprefix ../libuser/, $(user-obj-y))
+obj-y += $(addprefix ../libdis-user/, $(libdis-y))
+obj-y += $(libobj-y)
+
+endif #CONFIG_BSD_USER
+
+#########################################################
+# System emulator target
+ifdef CONFIG_SOFTMMU
+
+obj-y = arch_init.o cpus.o monitor.o machine.o gdbstub.o balloon.o ioport.o
+# virtio has to be here due to weird dependency between PCI and virtio-net.
+# need to fix this properly
+obj-$(CONFIG_NO_PCI) += pci-stub.o
+obj-$(CONFIG_VIRTIO) += virtio.o virtio-blk.o virtio-balloon.o virtio-net.o virtio-serial-bus.o
+obj-y += vhost_net.o
+obj-$(CONFIG_VHOST_NET) += vhost.o
+obj-$(CONFIG_REALLY_VIRTFS) += 9pfs/virtio-9p-device.o
+obj-$(CONFIG_KVM) += kvm.o kvm-all.o
+obj-$(CONFIG_NO_KVM) += kvm-stub.o
+obj-y += memory.o
+LIBS+=-lz -lrt -lm
+
+QEMU_CFLAGS += $(VNC_TLS_CFLAGS)
+QEMU_CFLAGS += $(VNC_SASL_CFLAGS)
+QEMU_CFLAGS += $(VNC_JPEG_CFLAGS)
+QEMU_CFLAGS += $(VNC_PNG_CFLAGS)
+QEMU_CFLAGS += $(GLIB_CFLAGS)
+
+# xen support
+obj-$(CONFIG_XEN) += xen-all.o xen_machine_pv.o xen_domainbuild.o xen-mapcache.o
+obj-$(CONFIG_NO_XEN) += xen-stub.o
+
+obj-i386-$(CONFIG_XEN) += xen_platform.o
+
+# Inter-VM PCI shared memory
+CONFIG_IVSHMEM =
+ifeq ($(CONFIG_KVM), y)
+  ifeq ($(CONFIG_PCI), y)
+    CONFIG_IVSHMEM = y
+  endif
+endif
+obj-$(CONFIG_IVSHMEM) += ivshmem.o
+
+# Hardware support
+obj-i386-y += vga.o
+obj-i386-y += mc146818rtc.o pc.o
+obj-i386-y += cirrus_vga.o sga.o apic.o ioapic.o piix_pci.o
+obj-i386-y += vmport.o
+obj-i386-y += device-hotplug.o pci-hotplug.o smbios.o wdt_ib700.o
+obj-i386-y += debugcon.o multiboot.o
+obj-i386-y += pc_piix.o
+obj-i386-$(CONFIG_KVM) += kvmclock.o
+obj-i386-$(CONFIG_SPICE) += qxl.o qxl-logger.o qxl-render.o
+
+# shared objects
+obj-ppc-y = ppc.o ppc_booke.o
+obj-ppc-y += vga.o
+# PREP target
+obj-ppc-y += mc146818rtc.o
+obj-ppc-y += ppc_prep.o
+# OldWorld PowerMac
+obj-ppc-y += ppc_oldworld.o
+# NewWorld PowerMac
+obj-ppc-y += ppc_newworld.o
+# IBM pSeries (sPAPR)
+obj-ppc-$(CONFIG_PSERIES) += spapr.o spapr_hcall.o spapr_rtas.o spapr_vio.o
+obj-ppc-$(CONFIG_PSERIES) += xics.o spapr_vty.o spapr_llan.o spapr_vscsi.o
+obj-ppc-$(CONFIG_PSERIES) += spapr_pci.o device-hotplug.o pci-hotplug.o
+# PowerPC 4xx boards
+obj-ppc-y += ppc4xx_devs.o ppc4xx_pci.o ppc405_uc.o ppc405_boards.o
+obj-ppc-y += ppc440.o ppc440_bamboo.o
+# PowerPC E500 boards
+obj-ppc-y += ppce500_mpc8544ds.o mpc8544_guts.o ppce500_spin.o
+# PowerPC 440 Xilinx ML507 reference board.
+obj-ppc-y += virtex_ml507.o
+obj-ppc-$(CONFIG_KVM) += kvm_ppc.o
+obj-ppc-$(CONFIG_FDT) += device_tree.o
+# PowerPC OpenPIC
+obj-ppc-y += openpic.o
+
+# Xilinx PPC peripherals
+obj-ppc-y += xilinx_intc.o
+obj-ppc-y += xilinx_timer.o
+obj-ppc-y += xilinx_uartlite.o
+obj-ppc-y += xilinx_ethlite.o
+
+# LM32 boards
+obj-lm32-y += lm32_boards.o
+obj-lm32-y += milkymist.o
+
+# LM32 peripherals
+obj-lm32-y += lm32_pic.o
+obj-lm32-y += lm32_juart.o
+obj-lm32-y += lm32_timer.o
+obj-lm32-y += lm32_uart.o
+obj-lm32-y += lm32_sys.o
+obj-lm32-y += milkymist-ac97.o
+obj-lm32-y += milkymist-hpdmc.o
+obj-lm32-y += milkymist-memcard.o
+obj-lm32-y += milkymist-minimac2.o
+obj-lm32-y += milkymist-pfpu.o
+obj-lm32-y += milkymist-softusb.o
+obj-lm32-y += milkymist-sysctl.o
+obj-lm32-$(CONFIG_OPENGL) += milkymist-tmu2.o
+obj-lm32-y += milkymist-uart.o
+obj-lm32-y += milkymist-vgafb.o
+obj-lm32-y += framebuffer.o
+
+obj-mips-y = mips_r4k.o mips_jazz.o mips_malta.o mips_mipssim.o mips_octeon.o
+obj-mips-y += mips_addr.o mips_timer.o mips_int.o
+obj-mips-y += vga.o
+obj-mips-y += jazz_led.o
+obj-mips-y += gt64xxx.o mc146818rtc.o
+obj-mips-y += cirrus_vga.o
+obj-mips-$(CONFIG_FULONG) += bonito.o vt82c686.o mips_fulong2e.o
+
+obj-microblaze-y = petalogix_s3adsp1800_mmu.o
+obj-microblaze-y += petalogix_ml605_mmu.o
+
+obj-microblaze-y += microblaze_pic_cpu.o
+obj-microblaze-y += xilinx_intc.o
+obj-microblaze-y += xilinx_timer.o
+obj-microblaze-y += xilinx_uartlite.o
+obj-microblaze-y += xilinx_ethlite.o
+obj-microblaze-y += xilinx_axidma.o
+obj-microblaze-y += xilinx_axienet.o
+
+obj-microblaze-$(CONFIG_FDT) += device_tree.o
+
+# Boards
+obj-cris-y = cris_pic_cpu.o
+obj-cris-y += cris-boot.o
+obj-cris-y += axis_dev88.o
+
+# IO blocks
+obj-cris-y += etraxfs_dma.o
+obj-cris-y += etraxfs_pic.o
+obj-cris-y += etraxfs_eth.o
+obj-cris-y += etraxfs_timer.o
+obj-cris-y += etraxfs_ser.o
+
+ifeq ($(TARGET_ARCH), sparc64)
+obj-sparc-y = sun4u.o apb_pci.o
+obj-sparc-y += vga.o
+obj-sparc-y += mc146818rtc.o
+obj-sparc-y += cirrus_vga.o
+else
+obj-sparc-y = sun4m.o lance.o tcx.o sun4m_iommu.o slavio_intctl.o
+obj-sparc-y += slavio_timer.o slavio_misc.o sparc32_dma.o
+obj-sparc-y += cs4231.o eccmemctl.o sbi.o sun4c_intctl.o leon3.o
+
+# GRLIB
+obj-sparc-y += grlib_gptimer.o grlib_irqmp.o grlib_apbuart.o
+endif
+
+obj-arm-y = integratorcp.o versatilepb.o arm_pic.o arm_timer.o
+obj-arm-y += arm_boot.o pl011.o pl031.o pl050.o pl080.o pl110.o pl181.o pl190.o
+obj-arm-y += versatile_pci.o
+obj-arm-y += realview_gic.o realview.o arm_sysctl.o arm11mpcore.o a9mpcore.o
+obj-arm-y += armv7m.o armv7m_nvic.o stellaris.o pl022.o stellaris_enet.o
+obj-arm-y += pl061.o
+obj-arm-y += arm-semi.o
+obj-arm-y += pxa2xx.o pxa2xx_pic.o pxa2xx_gpio.o pxa2xx_timer.o pxa2xx_dma.o
+obj-arm-y += pxa2xx_lcd.o pxa2xx_mmci.o pxa2xx_pcmcia.o pxa2xx_keypad.o
+obj-arm-y += gumstix.o
+obj-arm-y += zaurus.o ide/microdrive.o spitz.o tosa.o tc6393xb.o
+obj-arm-y += omap1.o omap_lcdc.o omap_dma.o omap_clk.o omap_mmc.o omap_i2c.o \
+		omap_gpio.o omap_intc.o omap_uart.o
+obj-arm-y += omap2.o omap_dss.o soc_dma.o omap_gptimer.o omap_synctimer.o \
+		omap_gpmc.o omap_sdrc.o omap_spi.o omap_tap.o omap_l4.o
+obj-arm-y += omap_sx1.o palm.o tsc210x.o
+obj-arm-y += nseries.o blizzard.o onenand.o vga.o cbus.o tusb6010.o usb-musb.o
+obj-arm-y += mst_fpga.o mainstone.o
+obj-arm-y += z2.o
+obj-arm-y += musicpal.o bitbang_i2c.o marvell_88w8618_audio.o
+obj-arm-y += framebuffer.o
+obj-arm-y += syborg.o syborg_fb.o syborg_interrupt.o syborg_keyboard.o
+obj-arm-y += syborg_serial.o syborg_timer.o syborg_pointer.o syborg_rtc.o
+obj-arm-y += syborg_virtio.o
+obj-arm-y += vexpress.o
+obj-arm-y += strongarm.o
+obj-arm-y += collie.o
+obj-arm-y += pl041.o lm4549.o
+
+obj-sh4-y = shix.o r2d.o sh7750.o sh7750_regnames.o tc58128.o
+obj-sh4-y += sh_timer.o sh_serial.o sh_intc.o sh_pci.o sm501.o
+obj-sh4-y += ide/mmio.o
+
+obj-m68k-y = an5206.o mcf5206.o mcf_uart.o mcf_intc.o mcf5208.o mcf_fec.o
+obj-m68k-y += m68k-semi.o dummy_m68k.o
+
+obj-s390x-y = s390-virtio-bus.o s390-virtio.o
+
+obj-alpha-y = mc146818rtc.o
+obj-alpha-y += vga.o cirrus_vga.o
+obj-alpha-y += alpha_pci.o alpha_dp264.o alpha_typhoon.o
+
+obj-xtensa-y += xtensa_pic.o
+obj-xtensa-y += xtensa_sim.o
+obj-xtensa-y += xtensa_lx60.o
+obj-xtensa-y += xtensa-semi.o
+obj-xtensa-y += core-dc232b.o
+obj-xtensa-y += core-fsf.o
+
+main.o: QEMU_CFLAGS+=$(GPROF_CFLAGS)
+
+monitor.o: hmp-commands.h qmp-commands-old.h
+
+$(obj-y) $(obj-$(TARGET_BASE_ARCH)-y): $(GENERATED_HEADERS)
+
+obj-y += $(addprefix ../, $(common-obj-y))
+obj-y += $(addprefix ../libdis/, $(libdis-y))
+obj-y += $(libobj-y)
+obj-y += $(addprefix $(HWDIR)/, $(hw-obj-y))
+obj-y += $(addprefix ../, $(trace-obj-y))
+
+endif # CONFIG_SOFTMMU
+
+ifndef CONFIG_LINUX_USER
+ifndef CONFIG_BSD_USER
+# libcacard needs qemu-thread support, and besides is only needed by devices
+# so not requires with linux-user / bsd-user targets
+obj-$(CONFIG_SMARTCARD_NSS) += $(addprefix ../libcacard/, $(libcacard-y))
+endif # CONFIG_BSD_USER
+endif # CONFIG_LINUX_USER
+
+obj-$(CONFIG_GDBSTUB_XML) += gdbstub-xml.o
+
+$(QEMU_PROG): $(obj-y) $(obj-$(TARGET_BASE_ARCH)-y)
+	$(call LINK,$^)
+
+
+gdbstub-xml.c: $(TARGET_XML_FILES) $(SRC_PATH)/scripts/feature_to_c.sh
+	$(call quiet-command,rm -f $@ && $(SHELL) $(SRC_PATH)/scripts/feature_to_c.sh $@ $(TARGET_XML_FILES),"  GEN   $(TARGET_DIR)$@")
+
+hmp-commands.h: $(SRC_PATH)/hmp-commands.hx
+	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"  GEN   $(TARGET_DIR)$@")
+
+qmp-commands-old.h: $(SRC_PATH)/qmp-commands.hx
+	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"  GEN   $(TARGET_DIR)$@")
+
+clean:
+	rm -f *.o *.a *~ $(PROGS) nwfpe/*.o fpu/*.o
+	rm -f *.d */*.d tcg/*.o ide/*.o 9pfs/*.o
+	rm -f hmp-commands.h qmp-commands-old.h gdbstub-xml.c
+ifdef CONFIG_TRACE_SYSTEMTAP
+	rm -f *.stp
+endif
+
+install: all
+ifneq ($(PROGS),)
+	$(INSTALL) -m 755 $(PROGS) "$(DESTDIR)$(bindir)"
+ifneq ($(STRIP),)
+	$(STRIP) $(patsubst %,"$(DESTDIR)$(bindir)/%",$(PROGS))
+endif
+endif
+ifdef CONFIG_TRACE_SYSTEMTAP
+	$(INSTALL_DIR) "$(DESTDIR)$(datadir)/../systemtap/tapset"
+	$(INSTALL_DATA) $(QEMU_PROG).stp "$(DESTDIR)$(datadir)/../systemtap/tapset"
+endif
+
+# Include automatically generated dependency files
+-include $(wildcard *.d */*.d)
diff -rupN qemu-1.0.1/qapi-types.h modified_QEMU/qapi-types.h
--- qemu-1.0.1/qapi-types.h	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/qapi-types.h	2015-02-11 23:16:40.625196000 -0800
@@ -0,0 +1,591 @@
+/* AUTOMATICALLY GENERATED, DO NOT MODIFY */
+
+/*
+ * schema-defined QAPI types
+ *
+ * Copyright IBM, Corp. 2011
+ *
+ * Authors:
+ *  Anthony Liguori   <aliguori@us.ibm.com>
+ *
+ * This work is licensed under the terms of the GNU LGPL, version 2.1 or later.
+ * See the COPYING.LIB file in the top-level directory.
+ *
+ */
+
+#ifndef QAPI_TYPES_H
+#define QAPI_TYPES_H
+
+#include "qapi/qapi-types-core.h"
+
+typedef struct NameInfo NameInfo;
+
+typedef struct NameInfoList
+{
+    NameInfo *value;
+    struct NameInfoList *next;
+} NameInfoList;
+
+typedef struct VersionInfo VersionInfo;
+
+typedef struct VersionInfoList
+{
+    VersionInfo *value;
+    struct VersionInfoList *next;
+} VersionInfoList;
+
+typedef struct KvmInfo KvmInfo;
+
+typedef struct KvmInfoList
+{
+    KvmInfo *value;
+    struct KvmInfoList *next;
+} KvmInfoList;
+
+extern const char *RunState_lookup[];
+typedef enum RunState
+{
+    RUN_STATE_DEBUG = 0,
+    RUN_STATE_INMIGRATE = 1,
+    RUN_STATE_INTERNAL_ERROR = 2,
+    RUN_STATE_IO_ERROR = 3,
+    RUN_STATE_PAUSED = 4,
+    RUN_STATE_POSTMIGRATE = 5,
+    RUN_STATE_PRELAUNCH = 6,
+    RUN_STATE_FINISH_MIGRATE = 7,
+    RUN_STATE_RESTORE_VM = 8,
+    RUN_STATE_RUNNING = 9,
+    RUN_STATE_SAVE_VM = 10,
+    RUN_STATE_SHUTDOWN = 11,
+    RUN_STATE_WATCHDOG = 12,
+    RUN_STATE_MAX = 13,
+} RunState;
+
+typedef struct StatusInfo StatusInfo;
+
+typedef struct StatusInfoList
+{
+    StatusInfo *value;
+    struct StatusInfoList *next;
+} StatusInfoList;
+
+typedef struct UuidInfo UuidInfo;
+
+typedef struct UuidInfoList
+{
+    UuidInfo *value;
+    struct UuidInfoList *next;
+} UuidInfoList;
+
+typedef struct ChardevInfo ChardevInfo;
+
+typedef struct ChardevInfoList
+{
+    ChardevInfo *value;
+    struct ChardevInfoList *next;
+} ChardevInfoList;
+
+typedef struct CommandInfo CommandInfo;
+
+typedef struct CommandInfoList
+{
+    CommandInfo *value;
+    struct CommandInfoList *next;
+} CommandInfoList;
+
+typedef struct MigrationStats MigrationStats;
+
+typedef struct MigrationStatsList
+{
+    MigrationStats *value;
+    struct MigrationStatsList *next;
+} MigrationStatsList;
+
+typedef struct MigrationInfo MigrationInfo;
+
+typedef struct MigrationInfoList
+{
+    MigrationInfo *value;
+    struct MigrationInfoList *next;
+} MigrationInfoList;
+
+typedef struct MouseInfo MouseInfo;
+
+typedef struct MouseInfoList
+{
+    MouseInfo *value;
+    struct MouseInfoList *next;
+} MouseInfoList;
+
+typedef struct CpuInfo CpuInfo;
+
+typedef struct CpuInfoList
+{
+    CpuInfo *value;
+    struct CpuInfoList *next;
+} CpuInfoList;
+
+typedef struct BlockDeviceInfo BlockDeviceInfo;
+
+typedef struct BlockDeviceInfoList
+{
+    BlockDeviceInfo *value;
+    struct BlockDeviceInfoList *next;
+} BlockDeviceInfoList;
+
+extern const char *BlockDeviceIoStatus_lookup[];
+typedef enum BlockDeviceIoStatus
+{
+    BLOCK_DEVICE_IO_STATUS_OK = 0,
+    BLOCK_DEVICE_IO_STATUS_FAILED = 1,
+    BLOCK_DEVICE_IO_STATUS_NOSPACE = 2,
+    BLOCK_DEVICE_IO_STATUS_MAX = 3,
+} BlockDeviceIoStatus;
+
+typedef struct BlockInfo BlockInfo;
+
+typedef struct BlockInfoList
+{
+    BlockInfo *value;
+    struct BlockInfoList *next;
+} BlockInfoList;
+
+typedef struct BlockDeviceStats BlockDeviceStats;
+
+typedef struct BlockDeviceStatsList
+{
+    BlockDeviceStats *value;
+    struct BlockDeviceStatsList *next;
+} BlockDeviceStatsList;
+
+typedef struct BlockStats BlockStats;
+
+typedef struct BlockStatsList
+{
+    BlockStats *value;
+    struct BlockStatsList *next;
+} BlockStatsList;
+
+typedef struct VncClientInfo VncClientInfo;
+
+typedef struct VncClientInfoList
+{
+    VncClientInfo *value;
+    struct VncClientInfoList *next;
+} VncClientInfoList;
+
+typedef struct VncInfo VncInfo;
+
+typedef struct VncInfoList
+{
+    VncInfo *value;
+    struct VncInfoList *next;
+} VncInfoList;
+
+typedef struct SpiceChannel SpiceChannel;
+
+typedef struct SpiceChannelList
+{
+    SpiceChannel *value;
+    struct SpiceChannelList *next;
+} SpiceChannelList;
+
+typedef struct SpiceInfo SpiceInfo;
+
+typedef struct SpiceInfoList
+{
+    SpiceInfo *value;
+    struct SpiceInfoList *next;
+} SpiceInfoList;
+
+typedef struct BalloonInfo BalloonInfo;
+
+typedef struct BalloonInfoList
+{
+    BalloonInfo *value;
+    struct BalloonInfoList *next;
+} BalloonInfoList;
+
+typedef struct PciMemoryRange PciMemoryRange;
+
+typedef struct PciMemoryRangeList
+{
+    PciMemoryRange *value;
+    struct PciMemoryRangeList *next;
+} PciMemoryRangeList;
+
+typedef struct PciMemoryRegion PciMemoryRegion;
+
+typedef struct PciMemoryRegionList
+{
+    PciMemoryRegion *value;
+    struct PciMemoryRegionList *next;
+} PciMemoryRegionList;
+
+typedef struct PciBridgeInfo PciBridgeInfo;
+
+typedef struct PciBridgeInfoList
+{
+    PciBridgeInfo *value;
+    struct PciBridgeInfoList *next;
+} PciBridgeInfoList;
+
+typedef struct PciDeviceInfo PciDeviceInfo;
+
+typedef struct PciDeviceInfoList
+{
+    PciDeviceInfo *value;
+    struct PciDeviceInfoList *next;
+} PciDeviceInfoList;
+
+typedef struct PciInfo PciInfo;
+
+typedef struct PciInfoList
+{
+    PciInfo *value;
+    struct PciInfoList *next;
+} PciInfoList;
+
+struct NameInfo
+{
+    bool has_name;
+    char * name;
+};
+
+void qapi_free_NameInfoList(NameInfoList * obj);
+void qapi_free_NameInfo(NameInfo * obj);
+
+struct VersionInfo
+{
+    struct 
+    {
+        int64_t major;
+        int64_t minor;
+        int64_t micro;
+    } qemu;
+    char * package;
+};
+
+void qapi_free_VersionInfoList(VersionInfoList * obj);
+void qapi_free_VersionInfo(VersionInfo * obj);
+
+struct KvmInfo
+{
+    bool enabled;
+    bool present;
+};
+
+void qapi_free_KvmInfoList(KvmInfoList * obj);
+void qapi_free_KvmInfo(KvmInfo * obj);
+
+struct StatusInfo
+{
+    bool running;
+    bool singlestep;
+    RunState status;
+};
+
+void qapi_free_StatusInfoList(StatusInfoList * obj);
+void qapi_free_StatusInfo(StatusInfo * obj);
+
+struct UuidInfo
+{
+    char * UUID;
+};
+
+void qapi_free_UuidInfoList(UuidInfoList * obj);
+void qapi_free_UuidInfo(UuidInfo * obj);
+
+struct ChardevInfo
+{
+    char * label;
+    char * filename;
+};
+
+void qapi_free_ChardevInfoList(ChardevInfoList * obj);
+void qapi_free_ChardevInfo(ChardevInfo * obj);
+
+struct CommandInfo
+{
+    char * name;
+};
+
+void qapi_free_CommandInfoList(CommandInfoList * obj);
+void qapi_free_CommandInfo(CommandInfo * obj);
+
+struct MigrationStats
+{
+    int64_t transferred;
+    int64_t remaining;
+    int64_t total;
+};
+
+void qapi_free_MigrationStatsList(MigrationStatsList * obj);
+void qapi_free_MigrationStats(MigrationStats * obj);
+
+struct MigrationInfo
+{
+    bool has_status;
+    char * status;
+    bool has_ram;
+    MigrationStats * ram;
+    bool has_disk;
+    MigrationStats * disk;
+};
+
+void qapi_free_MigrationInfoList(MigrationInfoList * obj);
+void qapi_free_MigrationInfo(MigrationInfo * obj);
+
+struct MouseInfo
+{
+    char * name;
+    int64_t index;
+    bool current;
+    bool absolute;
+};
+
+void qapi_free_MouseInfoList(MouseInfoList * obj);
+void qapi_free_MouseInfo(MouseInfo * obj);
+
+struct CpuInfo
+{
+    int64_t CPU;
+    bool current;
+    bool halted;
+    bool has_pc;
+    int64_t pc;
+    bool has_nip;
+    int64_t nip;
+    bool has_npc;
+    int64_t npc;
+    bool has_PC;
+    int64_t PC;
+    int64_t thread_id;
+};
+
+void qapi_free_CpuInfoList(CpuInfoList * obj);
+void qapi_free_CpuInfo(CpuInfo * obj);
+
+struct BlockDeviceInfo
+{
+    char * file;
+    bool ro;
+    char * drv;
+    bool has_backing_file;
+    char * backing_file;
+    bool encrypted;
+};
+
+void qapi_free_BlockDeviceInfoList(BlockDeviceInfoList * obj);
+void qapi_free_BlockDeviceInfo(BlockDeviceInfo * obj);
+
+struct BlockInfo
+{
+    char * device;
+    char * type;
+    bool removable;
+    bool locked;
+    bool has_inserted;
+    BlockDeviceInfo * inserted;
+    bool has_tray_open;
+    bool tray_open;
+    bool has_io_status;
+    BlockDeviceIoStatus io_status;
+};
+
+void qapi_free_BlockInfoList(BlockInfoList * obj);
+void qapi_free_BlockInfo(BlockInfo * obj);
+
+struct BlockDeviceStats
+{
+    int64_t rd_bytes;
+    int64_t wr_bytes;
+    int64_t rd_operations;
+    int64_t wr_operations;
+    int64_t flush_operations;
+    int64_t flush_total_time_ns;
+    int64_t wr_total_time_ns;
+    int64_t rd_total_time_ns;
+    int64_t wr_highest_offset;
+};
+
+void qapi_free_BlockDeviceStatsList(BlockDeviceStatsList * obj);
+void qapi_free_BlockDeviceStats(BlockDeviceStats * obj);
+
+struct BlockStats
+{
+    bool has_device;
+    char * device;
+    BlockDeviceStats * stats;
+    bool has_parent;
+    BlockStats * parent;
+};
+
+void qapi_free_BlockStatsList(BlockStatsList * obj);
+void qapi_free_BlockStats(BlockStats * obj);
+
+struct VncClientInfo
+{
+    char * host;
+    char * family;
+    char * service;
+    bool has_x509_dname;
+    char * x509_dname;
+    bool has_sasl_username;
+    char * sasl_username;
+};
+
+void qapi_free_VncClientInfoList(VncClientInfoList * obj);
+void qapi_free_VncClientInfo(VncClientInfo * obj);
+
+struct VncInfo
+{
+    bool enabled;
+    bool has_host;
+    char * host;
+    bool has_family;
+    char * family;
+    bool has_service;
+    char * service;
+    bool has_auth;
+    char * auth;
+    bool has_clients;
+    VncClientInfoList * clients;
+};
+
+void qapi_free_VncInfoList(VncInfoList * obj);
+void qapi_free_VncInfo(VncInfo * obj);
+
+struct SpiceChannel
+{
+    char * host;
+    char * family;
+    char * port;
+    int64_t connection_id;
+    int64_t channel_type;
+    int64_t channel_id;
+    bool tls;
+};
+
+void qapi_free_SpiceChannelList(SpiceChannelList * obj);
+void qapi_free_SpiceChannel(SpiceChannel * obj);
+
+struct SpiceInfo
+{
+    bool enabled;
+    bool has_host;
+    char * host;
+    bool has_port;
+    int64_t port;
+    bool has_tls_port;
+    int64_t tls_port;
+    bool has_auth;
+    char * auth;
+    bool has_compiled_version;
+    char * compiled_version;
+    bool has_channels;
+    SpiceChannelList * channels;
+};
+
+void qapi_free_SpiceInfoList(SpiceInfoList * obj);
+void qapi_free_SpiceInfo(SpiceInfo * obj);
+
+struct BalloonInfo
+{
+    int64_t actual;
+    bool has_mem_swapped_in;
+    int64_t mem_swapped_in;
+    bool has_mem_swapped_out;
+    int64_t mem_swapped_out;
+    bool has_major_page_faults;
+    int64_t major_page_faults;
+    bool has_minor_page_faults;
+    int64_t minor_page_faults;
+    bool has_free_mem;
+    int64_t free_mem;
+    bool has_total_mem;
+    int64_t total_mem;
+};
+
+void qapi_free_BalloonInfoList(BalloonInfoList * obj);
+void qapi_free_BalloonInfo(BalloonInfo * obj);
+
+struct PciMemoryRange
+{
+    int64_t base;
+    int64_t limit;
+};
+
+void qapi_free_PciMemoryRangeList(PciMemoryRangeList * obj);
+void qapi_free_PciMemoryRange(PciMemoryRange * obj);
+
+struct PciMemoryRegion
+{
+    int64_t bar;
+    char * type;
+    int64_t address;
+    int64_t size;
+    bool has_prefetch;
+    bool prefetch;
+    bool has_mem_type_64;
+    bool mem_type_64;
+};
+
+void qapi_free_PciMemoryRegionList(PciMemoryRegionList * obj);
+void qapi_free_PciMemoryRegion(PciMemoryRegion * obj);
+
+struct PciBridgeInfo
+{
+    struct 
+    {
+        int64_t number;
+        int64_t secondary;
+        int64_t subordinate;
+        PciMemoryRange * io_range;
+        PciMemoryRange * memory_range;
+        PciMemoryRange * prefetchable_range;
+    } bus;
+    bool has_devices;
+    PciDeviceInfoList * devices;
+};
+
+void qapi_free_PciBridgeInfoList(PciBridgeInfoList * obj);
+void qapi_free_PciBridgeInfo(PciBridgeInfo * obj);
+
+struct PciDeviceInfo
+{
+    int64_t bus;
+    int64_t slot;
+    int64_t function;
+    struct 
+    {
+        bool has_desc;
+        char * desc;
+        int64_t class;
+    } class_info;
+    struct 
+    {
+        int64_t device;
+        int64_t vendor;
+    } id;
+    bool has_irq;
+    int64_t irq;
+    char * qdev_id;
+    bool has_pci_bridge;
+    PciBridgeInfo * pci_bridge;
+    PciMemoryRegionList * regions;
+};
+
+void qapi_free_PciDeviceInfoList(PciDeviceInfoList * obj);
+void qapi_free_PciDeviceInfo(PciDeviceInfo * obj);
+
+struct PciInfo
+{
+    int64_t bus;
+    PciDeviceInfoList * devices;
+};
+
+void qapi_free_PciInfoList(PciInfoList * obj);
+void qapi_free_PciInfo(PciInfo * obj);
+
+#endif
diff -rupN qemu-1.0.1/qapi-visit.h modified_QEMU/qapi-visit.h
--- qemu-1.0.1/qapi-visit.h	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/qapi-visit.h	2015-02-11 23:16:39.124193000 -0800
@@ -0,0 +1,101 @@
+/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT MODIFY */
+
+/*
+ * schema-defined QAPI visitor function
+ *
+ * Copyright IBM, Corp. 2011
+ *
+ * Authors:
+ *  Anthony Liguori   <aliguori@us.ibm.com>
+ *
+ * This work is licensed under the terms of the GNU LGPL, version 2.1 or later.
+ * See the COPYING.LIB file in the top-level directory.
+ *
+ */
+
+#ifndef QAPI_VISIT_H
+#define QAPI_VISIT_H
+
+#include "qapi/qapi-visit-core.h"
+#include "qapi-types.h"
+
+void visit_type_NameInfo(Visitor *m, NameInfo ** obj, const char *name, Error **errp);
+void visit_type_NameInfoList(Visitor *m, NameInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_VersionInfo(Visitor *m, VersionInfo ** obj, const char *name, Error **errp);
+void visit_type_VersionInfoList(Visitor *m, VersionInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_KvmInfo(Visitor *m, KvmInfo ** obj, const char *name, Error **errp);
+void visit_type_KvmInfoList(Visitor *m, KvmInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_RunState(Visitor *m, RunState * obj, const char *name, Error **errp);
+
+void visit_type_StatusInfo(Visitor *m, StatusInfo ** obj, const char *name, Error **errp);
+void visit_type_StatusInfoList(Visitor *m, StatusInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_UuidInfo(Visitor *m, UuidInfo ** obj, const char *name, Error **errp);
+void visit_type_UuidInfoList(Visitor *m, UuidInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_ChardevInfo(Visitor *m, ChardevInfo ** obj, const char *name, Error **errp);
+void visit_type_ChardevInfoList(Visitor *m, ChardevInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_CommandInfo(Visitor *m, CommandInfo ** obj, const char *name, Error **errp);
+void visit_type_CommandInfoList(Visitor *m, CommandInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_MigrationStats(Visitor *m, MigrationStats ** obj, const char *name, Error **errp);
+void visit_type_MigrationStatsList(Visitor *m, MigrationStatsList ** obj, const char *name, Error **errp);
+
+void visit_type_MigrationInfo(Visitor *m, MigrationInfo ** obj, const char *name, Error **errp);
+void visit_type_MigrationInfoList(Visitor *m, MigrationInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_MouseInfo(Visitor *m, MouseInfo ** obj, const char *name, Error **errp);
+void visit_type_MouseInfoList(Visitor *m, MouseInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_CpuInfo(Visitor *m, CpuInfo ** obj, const char *name, Error **errp);
+void visit_type_CpuInfoList(Visitor *m, CpuInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_BlockDeviceInfo(Visitor *m, BlockDeviceInfo ** obj, const char *name, Error **errp);
+void visit_type_BlockDeviceInfoList(Visitor *m, BlockDeviceInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_BlockDeviceIoStatus(Visitor *m, BlockDeviceIoStatus * obj, const char *name, Error **errp);
+
+void visit_type_BlockInfo(Visitor *m, BlockInfo ** obj, const char *name, Error **errp);
+void visit_type_BlockInfoList(Visitor *m, BlockInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_BlockDeviceStats(Visitor *m, BlockDeviceStats ** obj, const char *name, Error **errp);
+void visit_type_BlockDeviceStatsList(Visitor *m, BlockDeviceStatsList ** obj, const char *name, Error **errp);
+
+void visit_type_BlockStats(Visitor *m, BlockStats ** obj, const char *name, Error **errp);
+void visit_type_BlockStatsList(Visitor *m, BlockStatsList ** obj, const char *name, Error **errp);
+
+void visit_type_VncClientInfo(Visitor *m, VncClientInfo ** obj, const char *name, Error **errp);
+void visit_type_VncClientInfoList(Visitor *m, VncClientInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_VncInfo(Visitor *m, VncInfo ** obj, const char *name, Error **errp);
+void visit_type_VncInfoList(Visitor *m, VncInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_SpiceChannel(Visitor *m, SpiceChannel ** obj, const char *name, Error **errp);
+void visit_type_SpiceChannelList(Visitor *m, SpiceChannelList ** obj, const char *name, Error **errp);
+
+void visit_type_SpiceInfo(Visitor *m, SpiceInfo ** obj, const char *name, Error **errp);
+void visit_type_SpiceInfoList(Visitor *m, SpiceInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_BalloonInfo(Visitor *m, BalloonInfo ** obj, const char *name, Error **errp);
+void visit_type_BalloonInfoList(Visitor *m, BalloonInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_PciMemoryRange(Visitor *m, PciMemoryRange ** obj, const char *name, Error **errp);
+void visit_type_PciMemoryRangeList(Visitor *m, PciMemoryRangeList ** obj, const char *name, Error **errp);
+
+void visit_type_PciMemoryRegion(Visitor *m, PciMemoryRegion ** obj, const char *name, Error **errp);
+void visit_type_PciMemoryRegionList(Visitor *m, PciMemoryRegionList ** obj, const char *name, Error **errp);
+
+void visit_type_PciBridgeInfo(Visitor *m, PciBridgeInfo ** obj, const char *name, Error **errp);
+void visit_type_PciBridgeInfoList(Visitor *m, PciBridgeInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_PciDeviceInfo(Visitor *m, PciDeviceInfo ** obj, const char *name, Error **errp);
+void visit_type_PciDeviceInfoList(Visitor *m, PciDeviceInfoList ** obj, const char *name, Error **errp);
+
+void visit_type_PciInfo(Visitor *m, PciInfo ** obj, const char *name, Error **errp);
+void visit_type_PciInfoList(Visitor *m, PciInfoList ** obj, const char *name, Error **errp);
+
+#endif
diff -rupN qemu-1.0.1/qemu-options.hx modified_QEMU/qemu-options.hx
--- qemu-1.0.1/qemu-options.hx	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/qemu-options.hx	2015-01-29 09:21:18.000000000 -0800
@@ -1799,18 +1799,13 @@ QEMU supports using either local sheepdo
 devices.
 
 Syntax for specifying a sheepdog device
-@table @list
-``sheepdog:<vdiname>''
-
-``sheepdog:<vdiname>:<snapid>''
-
-``sheepdog:<vdiname>:<tag>''
-
-``sheepdog:<host>:<port>:<vdiname>''
-
-``sheepdog:<host>:<port>:<vdiname>:<snapid>''
-
-``sheepdog:<host>:<port>:<vdiname>:<tag>''
+@table @code
+@item sheepdog:<vdiname>
+@item sheepdog:<vdiname>:<snapid>
+@item sheepdog:<vdiname>:<tag>
+@item sheepdog:<host>:<port>:<vdiname>
+@item sheepdog:<host>:<port>:<vdiname>:<snapid>
+@item sheepdog:<host>:<port>:<vdiname>:<tag>
 @end table
 
 Example
diff -rupN qemu-1.0.1/qmp-commands.h modified_QEMU/qmp-commands.h
--- qemu-1.0.1/qmp-commands.h	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/qmp-commands.h	2015-02-11 23:16:38.240192000 -0800
@@ -0,0 +1,65 @@
+/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT MODIFY */
+
+/*
+ * schema-defined QAPI function prototypes
+ *
+ * Copyright IBM, Corp. 2011
+ *
+ * Authors:
+ *  Anthony Liguori   <aliguori@us.ibm.com>
+ *
+ * This work is licensed under the terms of the GNU LGPL, version 2.1 or later.
+ * See the COPYING.LIB file in the top-level directory.
+ *
+ */
+
+#ifndef QMP_COMMANDS_H
+#define QMP_COMMANDS_H
+
+#include "qapi-types.h"
+#include "error.h"
+
+NameInfo * qmp_query_name(Error **errp);
+int qmp_marshal_input_query_name(Monitor *mon, const QDict *qdict, QObject **ret);
+VersionInfo * qmp_query_version(Error **errp);
+int qmp_marshal_input_query_version(Monitor *mon, const QDict *qdict, QObject **ret);
+KvmInfo * qmp_query_kvm(Error **errp);
+int qmp_marshal_input_query_kvm(Monitor *mon, const QDict *qdict, QObject **ret);
+StatusInfo * qmp_query_status(Error **errp);
+int qmp_marshal_input_query_status(Monitor *mon, const QDict *qdict, QObject **ret);
+UuidInfo * qmp_query_uuid(Error **errp);
+int qmp_marshal_input_query_uuid(Monitor *mon, const QDict *qdict, QObject **ret);
+ChardevInfoList * qmp_query_chardev(Error **errp);
+int qmp_marshal_input_query_chardev(Monitor *mon, const QDict *qdict, QObject **ret);
+CommandInfoList * qmp_query_commands(Error **errp);
+int qmp_marshal_input_query_commands(Monitor *mon, const QDict *qdict, QObject **ret);
+MigrationInfo * qmp_query_migrate(Error **errp);
+int qmp_marshal_input_query_migrate(Monitor *mon, const QDict *qdict, QObject **ret);
+MouseInfoList * qmp_query_mice(Error **errp);
+int qmp_marshal_input_query_mice(Monitor *mon, const QDict *qdict, QObject **ret);
+CpuInfoList * qmp_query_cpus(Error **errp);
+int qmp_marshal_input_query_cpus(Monitor *mon, const QDict *qdict, QObject **ret);
+BlockInfoList * qmp_query_block(Error **errp);
+int qmp_marshal_input_query_block(Monitor *mon, const QDict *qdict, QObject **ret);
+BlockStatsList * qmp_query_blockstats(Error **errp);
+int qmp_marshal_input_query_blockstats(Monitor *mon, const QDict *qdict, QObject **ret);
+VncInfo * qmp_query_vnc(Error **errp);
+int qmp_marshal_input_query_vnc(Monitor *mon, const QDict *qdict, QObject **ret);
+SpiceInfo * qmp_query_spice(Error **errp);
+int qmp_marshal_input_query_spice(Monitor *mon, const QDict *qdict, QObject **ret);
+BalloonInfo * qmp_query_balloon(Error **errp);
+int qmp_marshal_input_query_balloon(Monitor *mon, const QDict *qdict, QObject **ret);
+PciInfoList * qmp_query_pci(Error **errp);
+int qmp_marshal_input_query_pci(Monitor *mon, const QDict *qdict, QObject **ret);
+void qmp_quit(Error **errp);
+int qmp_marshal_input_quit(Monitor *mon, const QDict *qdict, QObject **ret);
+void qmp_stop(Error **errp);
+int qmp_marshal_input_stop(Monitor *mon, const QDict *qdict, QObject **ret);
+void qmp_system_reset(Error **errp);
+int qmp_marshal_input_system_reset(Monitor *mon, const QDict *qdict, QObject **ret);
+void qmp_system_powerdown(Error **errp);
+int qmp_marshal_input_system_powerdown(Monitor *mon, const QDict *qdict, QObject **ret);
+void qmp_cpu(int64_t index, Error **errp);
+int qmp_marshal_input_cpu(Monitor *mon, const QDict *qdict, QObject **ret);
+
+#endif
diff -rupN qemu-1.0.1/roms/ipxe/src/bin/.gitignore modified_QEMU/roms/ipxe/src/bin/.gitignore
--- qemu-1.0.1/roms/ipxe/src/bin/.gitignore	2012-02-17 11:46:04.000000000 -0800
+++ modified_QEMU/roms/ipxe/src/bin/.gitignore	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-*
diff -rupN qemu-1.0.1/roms/ipxe/src/config/local/.gitignore modified_QEMU/roms/ipxe/src/config/local/.gitignore
--- qemu-1.0.1/roms/ipxe/src/config/local/.gitignore	2012-02-17 11:46:04.000000000 -0800
+++ modified_QEMU/roms/ipxe/src/config/local/.gitignore	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-*
diff -rupN qemu-1.0.1/roms/seabios/config.mak modified_QEMU/roms/seabios/config.mak
--- qemu-1.0.1/roms/seabios/config.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/roms/seabios/config.mak	2015-02-11 23:03:07.079967000 -0800
@@ -0,0 +1,8 @@
+# Automatically generated by configure - do not modify
+SRC_PATH=/home/maryam/Documents/codeWithSmpEnabled/host_ayaz89/roms/seabios
+CC=gcc
+BCC=bcc
+CPP=cpp
+OBJCOPY=objcopy
+IASL=iasl
+LD=ld
diff -rupN qemu-1.0.1/roms/SLOF/clients/net-snk/make.depend modified_QEMU/roms/SLOF/clients/net-snk/make.depend
--- qemu-1.0.1/roms/SLOF/clients/net-snk/make.depend	2012-02-17 11:45:49.000000000 -0800
+++ modified_QEMU/roms/SLOF/clients/net-snk/make.depend	1969-12-31 16:00:00.000000000 -0800
@@ -1,36 +0,0 @@
-# *****************************************************************************
-# * Copyright (c) 2004, 2008 IBM Corporation
-# * All rights reserved.
-# * This program and the accompanying materials
-# * are made available under the terms of the BSD License
-# * which accompanies this distribution, and is available at
-# * http://www.opensource.org/licenses/bsd-license.php
-# *
-# * Contributors:
-# *     IBM Corporation - initial implementation
-# ****************************************************************************/
-
--include .depend
-
-depend :
-	@rm -rf .depend
-ifdef OBJS
-	@touch .depend && \
-	$(CC) -M $(CPPFLAGS) $(CFLAGS) $(OBJS:.o=.c) >> .depend
-#else
-#	@echo "OBJ is NOT defined"
-endif
-ifdef OBJS2
-	@$(CC) -M $(CPPFLAGS) $(CFLAGS) $(OBJS2:.o=.S) >> .depend
-#else
-#	@echo "OBJ2 is NOT definde"
-endif
-	@for dir in $(SUBDIRS); do \
-		$(MAKE) -C $$dir depend ; \
-	done
-
-mrproper : 
-	@rm -rf .depend ; \
-	for dir in $(SUBDIRS); do \
-		$(MAKE) -C $$dir mrproper ; \
-	done
Binary files qemu-1.0.1/roms/SLOF/FlashingSLOF.pdf and modified_QEMU/roms/SLOF/FlashingSLOF.pdf differ
diff -rupN qemu-1.0.1/roms/vgabios/config.mak modified_QEMU/roms/vgabios/config.mak
--- qemu-1.0.1/roms/vgabios/config.mak	1969-12-31 16:00:00.000000000 -0800
+++ modified_QEMU/roms/vgabios/config.mak	2015-02-11 23:03:07.084967000 -0800
@@ -0,0 +1,8 @@
+# Automatically generated by configure - do not modify
+SRC_PATH=/home/maryam/Documents/codeWithSmpEnabled/host_ayaz89/roms/vgabios
+CC=gcc
+BCC=bcc
+CPP=cpp
+OBJCOPY=objcopy
+IASL=iasl
+LD=ld
Binary files qemu-1.0.1/scripts/ordereddict.pyc and modified_QEMU/scripts/ordereddict.pyc differ
Binary files qemu-1.0.1/scripts/qapi.pyc and modified_QEMU/scripts/qapi.pyc differ
diff -rupN qemu-1.0.1/softmmu_template.h modified_QEMU/softmmu_template.h
--- qemu-1.0.1/softmmu_template.h	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/softmmu_template.h	2015-01-29 09:21:22.000000000 -0800
@@ -22,7 +22,17 @@
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
 #include "qemu-timer.h"
-
+#include <time.h>
+//#define UARTLOW 0xffffffffb40003f8
+//#define UARTHI  0xffffffffb40003ff
+#define UARTLO  0xffffffffb80003f8
+#define UARTHI  0xffffffffb80003ff
+extern int ayaz;
+extern int ayaz2;
+extern int glob_e1000_int;
+extern int glob_uart_int;
+extern CPUState * envArray[12];
+int state1,state2,state3,state4,state5,state6,state7,state8,state9,state10,state11,state12;
 #define DATA_SIZE (1 << SHIFT)
 
 #if DATA_SIZE == 8
@@ -62,6 +72,77 @@ static inline DATA_TYPE glue(io_read, SU
 {
     DATA_TYPE res;
     int index;
+     uint64_t ciu_sum0_address; //added by maryyam
+   
+              //  if ((addr>=0x8001070000000000 && addr<=0x80010700000000B8) || (addr>=0x8001070000000200 && addr<=0x8001070000000370 )){
+              //  ciu_sum0_address = 0x100000000;
+              // printf("\nio_read:  ciu_sum0_address: %lx\n", ciu_sum0_address);
+              // return ciu_sum0_address;
+              //  }  
+               if(((addr==0x8001070000000000 || addr==0x8001070000000200 )) && (state1==1)){
+                ciu_sum0_address = 0x100000000;
+              //  if(addr!=0x8001070000000000 && addr!= 0x8001070000000200){
+              // printf("addr: %lx\n", addr);
+              //  }
+               return ciu_sum0_address;
+                }
+    
+                if(((addr==0x8001070000000010 || addr==0x8001070000000220 ))&& (state2==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+              
+               if(((addr==0x8001070000000020 || addr==0x8001070000000240 )) && (state3==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+    
+                if(((addr==0x8001070000000030 || addr==0x8001070000000260 )) && (state4==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+                
+                if(((addr==0x8001070000000040 || addr==0x8001070000000280 )) && (state5==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+    
+                 if(((addr==0x8001070000000050 || addr==0x80010700000002a0 )) && (state6==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+                
+                 if(((addr==0x8001070000000060 || addr==0x80010700000002c0 )) && (state7==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+    
+                 if(((addr==0x8001070000000070 || addr==0x80010700000002e0 )) && (state8==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+    
+                if(((addr==0x8001070000000080 || addr==0x8001070000000300 )) && (state9==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+                
+                if(((addr==0x8001070000000090 || addr==0x8001070000000320 )) && (state10==1)){
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+    
+                if(((addr==0x80010700000000a0 || addr==0x8001070000000340 )) && (state11==1)){
+                 //   printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^11");
+                ciu_sum0_address = 0x100000000;
+               return ciu_sum0_address;
+                }
+                
+                if(((addr==0x80010700000000b0 || addr==0x8001070000000360 )) && (state12==1)){
+                ciu_sum0_address = 0x100000000;
+               // printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^12");
+               return ciu_sum0_address;
+                }
     index = (physaddr >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);
     physaddr = (physaddr & TARGET_PAGE_MASK) + addr;
     env->mem_io_pc = (unsigned long)retaddr;
@@ -71,6 +152,29 @@ static inline DATA_TYPE glue(io_read, SU
     }
 
     env->mem_io_vaddr = addr;
+
+     if( addr == 0xffffffffbbe00cfc)  //reading from pci config space
+        {   physaddr= 0xcfc;
+            index=10;
+			res = io_mem_read[index][2](io_mem_opaque[index], physaddr) ;//>> 16;
+			
+			return res;
+			}
+
+ if(addr >= 0x80011A001fbf0000 && addr <= 0x80011A001fbfffff)
+ {
+           res = io_mem_read[index][2](io_mem_opaque[index], physaddr) ;//>> 16;
+
+			res = bswap32(res);
+			return res;
+	}
+
+    if(addr >= UARTLO && addr <= UARTHI)
+    {
+    	res = io_mem_read[index][0](io_mem_opaque[index], physaddr);
+    	return res;
+    }
+
 #if SHIFT <= 2
     res = io_mem_read[index][SHIFT](io_mem_opaque[index], physaddr);
 #else
@@ -88,25 +192,140 @@ static inline DATA_TYPE glue(io_read, SU
 /* handle all cases except unaligned access which span two pages */
 DATA_TYPE REGPARM glue(glue(__ld, SUFFIX), MMUSUFFIX)(target_ulong addr,
                                                       int mmu_idx)
-{
+{   int mem_offset=0;
     DATA_TYPE res;
     int index;
     target_ulong tlb_addr;
     target_phys_addr_t ioaddr;
     unsigned long addend;
     void *retaddr;
+    int hhhh=0;
+
+	if(addr >= 0xffffffffbf000000 && addr <= 0xffffffffbf00003f)
+	{
+	       hhhh=1;
+
+	}
+
+
+
+	 if(addr == 0x8001070000000000)
+	{  //If guest wants to access CIU INT0 summary register
+	   if(glob_e1000_int == 1){
+		   glob_e1000_int=0;
+	     return 0x1000000000;  //return that there is a network interrupt
+	}
+	   else if(glob_uart_int == 1){
+		   glob_uart_int=0;
+		  return 0x800000000;   //return that there is a uart interrupt
+	   }
+
+	}
+
+	  if (addr == 0x8001070000000200)
+	  { //If guest wants to access CIU INT0 enable register
+
+	     return 0x88006F1800000000;
+	     }
+
+
+
+	
+	
+	
+
+    if(addr >= 0x8001190000000000 && addr <= 0x8001190FFFFFFFFF)
+{
+	   mem_offset=addr-0x8001190000000000;
+           addr=mem_offset+0x8000000010000000;
+
+
+	}
+
+   if(addr >= 0x80011A0000000000 && addr <= 0x80011A0FFFFFFFFF)
+{  ayaz=1;
+	}
+	   if(addr >= 0x80011B0000000000 && addr <= 0x80011E0FFFFFFFFF)
+{
+	mem_offset=addr-0x8001190000000000;
+           addr=mem_offset+0x8000000010000000;
+           //0xffffffffc0000000;
+
+	}
+//Following code and similar code in __st, io_read and io_write 
+//is written by Ayaz Akram
+switch(addr){
+
+   case 0x8001180000000800: 
+   case 0x8001180000000C00:    addr=0xffffffffb80003f8;  //RBR
+			       break;
+
+    case 0x8001180000000808: 
+    case 0x8001180000000C08:   addr=0xffffffffb80003f9;   //IER
+                               break;
+
+    case 0x8001180000000810: 
+    case 0x8001180000000C10:  addr=0xffffffffb80003fA;   //IIR
+                              break;
+
+     case 0x8001180000000818: 
+     case 0x8001180000000C18:  addr=0xffffffffb80003fB;    //LCR
+                               break;
+
+     case 0x8001180000000820: 
+     case 0x8001180000000C20:  addr=0xffffffffb80003fC;        //MCR
+                               break;
+
+     case 0x8001180000000828: 
+     case 0x8001180000000C28:  addr=0xffffffffb80003fD;      //LSR
+                               break;
+
+     case 0x8001180000000830: 
+     case 0x8001180000000C30: addr=0xffffffffb80003fE;       //MSR
+                              break;
+
+     case 0x8001180000000838: 
+     case 0x8001180000000C38: addr=0xffffffffb80003ff;      //SCR
+                              break;
+
+     case 0x8001180000000840: 
+     case 0x8001180000000C40:  addr=0xffffffffb80003f8;      //THR
+			       break;
+
+     case 0x8001180000000850: 
+     case 0x8001180000000C50:  addr=0xffffffffb80003fA;      //FCR
+                               break;
+
+     case 0x8001180000000880: 
+     case 0x8001180000000C80: addr=0xffffffffb80003f8;       //DLL
+                              break;
+
+    case 0x8001180000000888:  
+    case 0x8001180000000C88: addr=0xffffffffb80003f9;     //DLH
+                             break;
+
+    default:		     break;
+}
 
     /* test if there is match for unaligned or IO access */
     /* XXX: could done more in memory macro in a non portable way */
     index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
  redo:
     tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;
-    if ((addr & TARGET_PAGE_MASK) == (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {
+    if ((addr & TARGET_PAGE_MASK) == (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK)) ||  (addr >= 0xfffffffffebc0000 && addr <= 0xfffffffffebdffff)) {
         if (tlb_addr & ~TARGET_PAGE_MASK) {
             /* IO access */
-            if ((addr & (DATA_SIZE - 1)) != 0)
+             if(addr >= 0xfffffffffebc0000 && addr <= 0xfffffffffebdffff)
+            // if(addr >= 0x80011A0000000000 && addr <= 0x80011A0FFFFFFFFF)
+{
+         //s printf("\n E1000 :IO: add=%llx \n",addr);
+	}
+            if (((addr & (DATA_SIZE - 1)) != 0) && addr!=0xffffffffb80003fD && addr!=0xffffffffb80003f9 && addr!=0xffffffffb80003fA
+                    && addr!=0xffffffffb80003fB && addr!=0xffffffffb80003fC  &&  addr!=0xffffffffb80003fE  && addr!=0xffffffffb80003ff && !(addr >= 0xfffffffffebc0000 && addr <= 0xfffffffffebdffff))
                 goto do_unaligned_access;
             retaddr = GETPC();
+            if(addr >= 0xfffffffffebc0000 && addr <= 0xfffffffffebdffff)
+            printf("\n E1000 2 :IO: add=%llx \n",addr);
             ioaddr = env->iotlb[mmu_idx][index];
             res = glue(io_read, SUFFIX)(ioaddr, addr, retaddr);
         } else if (((addr & ~TARGET_PAGE_MASK) + DATA_SIZE - 1) >= TARGET_PAGE_SIZE) {
@@ -205,6 +424,120 @@ static inline void glue(io_write, SUFFIX
                                           void *retaddr)
 {
     int index;
+    uint64_t ciu_sum0_address;
+   // qemu_irq irq;
+  // CPUMIPSState * mips; 
+   //PITChannelState *s;
+  //  int n = 2;
+//   SerialState *s;
+ //  s->irq->n = 2;
+    /*Added by Maryyam to support smp interrupts, IPI*/
+     if (addr >= 0x8001070000000600 && addr <= 0x8001070000000658)
+    {
+        switch(addr){
+            case 0x8001070000000600:
+                // printf("\n*******cause0: %lx, Cause1: %lx phy_addr: %lx index: %lx*********1\n",envArray[0]->CP0_Cause, envArray[1]->CP0_Cause, physaddr, index);
+                         state1=0;
+                        envArray[0]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                        //cpu_interrupt(envArray[0], CPU_INTERRUPT_HARD);
+                        state1=1;
+                   /*  if (envArray[0]->CP0_Cause & CP0Ca_IP_mask) {
+                         printf("\nWaaooooo ITS HACK :D Cause %lx \n",envArray[0]->CP0_Cause);
+                          printf("\n*******cause0: %lx, Cause1: %lx*********\n", envArray[0]->CP0_Cause, envArray[1]->CP0_Cause);
+                         cpu_interrupt(envArray[0], CPU_INTERRUPT_HARD);
+                         printf("\nWaaooooo I am back from cpu_interrupt Cause %lx \n", envArray[0]->CP0_Cause);
+                     } else {
+                         cpu_reset_interrupt(envArray[0], CPU_INTERRUPT_HARD);
+                             } */
+             break;
+             
+            case 0x8001070000000608:
+                      //   printf("\n*******cause0: %lx, Cause1: %lx*********2\n",envArray[1]->CP0_Cause, envArray[1]->CP0_Cause);
+                        state2=0;
+                         envArray[1]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                         //cpu_interrupt(envArray[1], CPU_INTERRUPT_HARD);
+                         state2=1;
+                         
+ 
+             break;
+                   
+            case 0x8001070000000610:
+                        state3=0;
+                        envArray[2]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                        ///cpu_interrupt(envArray[2], CPU_INTERRUPT_HARD);
+                      //  printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^1");
+                        state3=1;
+                
+            break;
+            
+            case 0x8001070000000618:
+                        state4=0;
+                        envArray[3]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                         //cpu_interrupt(envArray[3], CPU_INTERRUPT_HARD);
+                        state4=1;
+                       // printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^2");
+            break;
+            
+            case 0x8001070000000620:
+                        state5=0;
+                         envArray[4]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                         //cpu_interrupt(envArray[4], CPU_INTERRUPT_HARD);
+                         state5=1;
+             break;
+             
+             case 0x8001070000000628:
+                        state6=0;
+                         envArray[5]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                         //cpu_interrupt(envArray[5], CPU_INTERRUPT_HARD);
+                         state6=1;
+             break;
+             
+             case 0x8001070000000630:
+                        state7=0;
+                         envArray[6]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                       // cpu_interrupt(envArray[6], CPU_INTERRUPT_HARD);
+                         state7=1;
+             break;
+             
+             case 0x8001070000000638:
+                        state8=0;
+                         envArray[7]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                         //cpu_interrupt(envArray[7], CPU_INTERRUPT_HARD);
+                         state8=1;
+             break;
+             
+             case 0x8001070000000640:
+                        state9=0;
+                         envArray[8]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                        // cpu_interrupt(envArray[8], CPU_INTERRUPT_HARD);
+                         state9=1;
+             break;
+             
+             case 0x8001070000000648:
+                        state10=0;
+                         envArray[9]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                         //cpu_interrupt(envArray[9], CPU_INTERRUPT_HARD);
+                         state10=1;
+             break;
+             
+             case 0x8001070000000650:
+                        state11=0;
+                      //  printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^1");
+                         envArray[10]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                         //cpu_interrupt(envArray[10], CPU_INTERRUPT_HARD);
+                         state11=1;
+             break;
+             
+             case 0x8001070000000658:
+                        state12=0;
+                      //  printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^2");
+                         envArray[11]->CP0_Cause |= 1 << (2 + CP0Ca_IP);
+                          //cpu_interrupt(envArray[11], CPU_INTERRUPT_HARD);
+                         state12=1;
+             break;
+        }
+    }
+    
     index = (physaddr >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);
     physaddr = (physaddr & TARGET_PAGE_MASK) + addr;
     if (index > (IO_MEM_NOTDIRTY >> IO_MEM_SHIFT)
@@ -214,6 +547,36 @@ static inline void glue(io_write, SUFFIX
 
     env->mem_io_vaddr = addr;
     env->mem_io_pc = (unsigned long)retaddr;
+     if(addr == 0xffffffffbbe00cf8)
+     { index=10;
+        physaddr=0xcf8;
+        io_mem_write[index][2](io_mem_opaque[index],physaddr,val);
+		 return;
+		 }
+	 if( addr == 0xffffffffbbe00cfc)
+	 {  index=10;
+	 physaddr=0xcfc;
+	 io_mem_write[index][2](io_mem_opaque[index],physaddr,val);
+	 return;
+		 }	//if(addr >= 0xfffffffffebc0000 && addr <= 0xfffffffffebdffff)	 
+		  //if(addr >=0x9000000000004000 && addr <=0x900000000FFFFFFF)
+		  if(addr >= 0x80011A001fbf0000 && addr <= 0x80011A001fbfffff)
+		   {    //printf("\n ST:E1000:addr:0x%llx \n",addr);
+		    ayaz2=1;
+		  val=bswap32(val);
+		  // val=val | 0x1c0;
+		  // val=val & 0x00000fff;
+			  io_mem_write[index][2](io_mem_opaque[index],physaddr,val);
+	          return;
+			  }
+		 
+		 
+    if(addr >= UARTLO && addr <= UARTHI)
+    {
+    	io_mem_write[index][0](io_mem_opaque[index], physaddr, val);
+    	return;
+    }
+
 #if SHIFT <= 2
     io_mem_write[index][SHIFT](io_mem_opaque[index], physaddr, val);
 #else
@@ -230,12 +593,100 @@ static inline void glue(io_write, SUFFIX
 void REGPARM glue(glue(__st, SUFFIX), MMUSUFFIX)(target_ulong addr,
                                                  DATA_TYPE val,
                                                  int mmu_idx)
-{
+{   int mem_offset=0;
     target_phys_addr_t ioaddr;
     unsigned long addend;
     target_ulong tlb_addr;
     void *retaddr;
     int index;
+    int i;
+   int casual;  
+   	if(addr >= 0xfffffffffebc0000 && addr <= 0xfffffffffebdffff)
+	//printf("\n ****E1000:ST: addr : 0x%llx \n",addr);
+    //if(addr==0x8001180000000c00){
+		
+		//printf("this is the address");
+		//}
+    
+//following hack was put in by Nouman so that user mode 
+//terminals work.  Now we don't need this code
+/*
+ if(addr==0x8001180000000c00)
+    {
+    fprintf(stderr,"%c",(char)val);
+    }
+*/
+//if(addr >=0x80011A00bf000000 && addr <=0x80011A00bf00003f)
+	//{ addr |= 0xffffffff00000000; 
+		//}
+
+if(addr >= 0xffffffffbf000000 && addr <= 0xffffffffbf00003f)
+	{   //addr &= 0x00000000ffffffff;
+		printf("\n ****E1000:ST: addr : 0x%llx and val=0x%llx \n",addr,val);
+	}
+   if(addr == 0xffffffffbbe00cf8)
+   {//printf("\n STORE: addr:0x%llx: val:0x%llx \n", addr,val);
+   val = val | 0x0000000080000000;  //value to be written in pci configuration space is manipulated according to Malta Mips
+    
+}
+
+
+
+
+	
+
+switch(addr){
+
+   case 0x8001180000000800: 
+   case 0x8001180000000C00:    addr=0xffffffffb80003f8;  //RBR
+			       break;
+
+    case 0x8001180000000808: 
+    case 0x8001180000000C08:   addr=0xffffffffb80003f9;   //IER
+                               break;
+
+    case 0x8001180000000810: 
+    case 0x8001180000000C10:  addr=0xffffffffb80003fA;   //IIR
+                              break;
+
+     case 0x8001180000000818: 
+     case 0x8001180000000C18:  addr=0xffffffffb80003fB;    //LCR
+                               break;
+
+     case 0x8001180000000820: 
+     case 0x8001180000000C20:  addr=0xffffffffb80003fC;        //MCR
+                               break;
+
+     case 0x8001180000000828: 
+     case 0x8001180000000C28:  addr=0xffffffffb80003fD;      //LSR
+                               break;
+
+     case 0x8001180000000830: 
+     case 0x8001180000000C30: addr=0xffffffffb80003fE;       //MSR
+                              break;
+
+     case 0x8001180000000838: 
+     case 0x8001180000000C38: addr=0xffffffffb80003ff;      //SCR
+                              break;
+
+     case 0x8001180000000840: 
+     case 0x8001180000000C40:  addr=0xffffffffb80003f8;      //THR
+			       break;
+
+     case 0x8001180000000850: 
+     case 0x8001180000000C50:  addr=0xffffffffb80003fA;      //FCR
+                               break;
+
+     case 0x8001180000000880: 
+     case 0x8001180000000C80: addr=0xffffffffb80003f8;       //DLL
+                              break;
+
+    case 0x8001180000000888:  
+    case 0x8001180000000C88: addr=0xffffffffb80003f9;     //DLH
+                             break;
+
+    default:		     break;
+}
 
     index = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
  redo:
@@ -243,7 +694,8 @@ void REGPARM glue(glue(__st, SUFFIX), MM
     if ((addr & TARGET_PAGE_MASK) == (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {
         if (tlb_addr & ~TARGET_PAGE_MASK) {
             /* IO access */
-            if ((addr & (DATA_SIZE - 1)) != 0)
+            if (((addr & (DATA_SIZE - 1)) != 0) && addr!=0xffffffffb80003fD && addr!=0xffffffffb80003f9 && addr!=0xffffffffb80003fA
+                    && addr!=0xffffffffb80003fB && addr!=0xffffffffb80003fC  &&  addr!=0xffffffffb80003fE  && addr!=0xffffffffb80003ff)
                 goto do_unaligned_access;
             retaddr = GETPC();
             ioaddr = env->iotlb[mmu_idx][index];
@@ -335,3 +787,4 @@ static void glue(glue(slow_st, SUFFIX),
 #undef USUFFIX
 #undef DATA_SIZE
 #undef ADDR_READ
+
diff -rupN qemu-1.0.1/target-mips/cpu.h modified_QEMU/target-mips/cpu.h
--- qemu-1.0.1/target-mips/cpu.h	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/target-mips/cpu.h	2015-01-29 09:21:18.000000000 -0800
@@ -173,6 +173,13 @@ struct TCState {
     target_ulong CP0_TCSchedule;
     target_ulong CP0_TCScheFBack;
     int32_t CP0_Debug_tcstatus;
+    /* Multiplier registers for Octeon */
+    target_ulong MPL0;
+    target_ulong MPL1;
+    target_ulong MPL2;
+    target_ulong P0;
+    target_ulong P1;
+    target_ulong P2;
 };
 
 typedef struct CPUMIPSState CPUMIPSState;
@@ -481,6 +488,10 @@ struct CPUMIPSState {
     const mips_def_t *cpu_model;
     void *irq[8];
     struct QEMUTimer *timer; /* Internal timer */
+    target_ulong CP0_CvmMemCtl;//Octeon
+    target_ulong CP0_CvmCtl;   //Octeon
+    target_ulong CP0_CvmCount;   //Octeon
+    target_ulong CP0_ICacheErr;	//Octeon	         
 };
 
 #if !defined(CONFIG_USER_ONLY)
diff -rupN qemu-1.0.1/target-mips/helper.c modified_QEMU/target-mips/helper.c
--- qemu-1.0.1/target-mips/helper.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/target-mips/helper.c	2015-01-29 09:21:18.000000000 -0800
@@ -103,6 +103,7 @@ static int get_physical_address (CPUStat
                                 int *prot, target_ulong address,
                                 int rw, int access_type)
 {
+   int sam=0; 
     /* User mode can only access useg/xuseg */
     int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;
     int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;
@@ -111,6 +112,11 @@ static int get_physical_address (CPUStat
     int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;
     int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;
     int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;
+
+    //One of CvmMemCtl bit tells that is CvmMemCtlSegment is enabled or not
+    target_ulong CvmMemCtl = 0x000000000100;
+
+    CvmMemCtl = CvmMemCtl & env->CP0_CvmMemCtl;
 #endif
     int ret = TLBRET_MATCH;
 
@@ -187,8 +193,45 @@ static int get_physical_address (CPUStat
         /* kseg3 */
         /* XXX: debug segment is not emulated */
         if (kernel_mode) {
-            ret = env->tlb->map_address(env, physical, prot, address, rw, access_type);
+		if(CvmMemCtl == 0x000000000100){
+		
+
+					{
+	    		//for cvmmemseg, virtual address == physical address for emulation purposes
+	    		//this is a hack. otherwise actual processor maps this region in DCACHE
+	    		//
+	    		//fprintf(stderr,"cvmseg is accessed\n");
+              		 // fprintf(stderr,"\n ...............Kernel Hack in place for CVMSEG=%lx...........\n",(unsigned long)address);
+			//*physical=address&0x000000000;
+
+			*physical=(address&0x510000000)+sam;
+			sam=sam+1;			
+
+	  		*prot = PAGE_READ | PAGE_WRITE;
+	    	
+			}
         } else {
+
+			ret = env->tlb->map_address(env, physical, prot, address, rw, access_type);
+
+		}//end of else
+
+        }
+/*Following hack is for user mode -- Written by Nouman*/
+
+	 else if ((address >= 0xffffffffffff8000ULL && address <= 0xFFFFFFFFFFFFBFFFULL))
+                 {
+
+//         fprintf(stderr,"\n ...............User Hack in place for CVMSEG=%lx...........\n",(unsigned long)address);
+
+		 	 	 	//	*physical=address&0x000000000;
+						 *physical=(address&0x510000000)+sam;
+			                         sam=sam+1;
+					//	*physical=address&0x0000000000fffff;
+		 	 	 		*prot = PAGE_READ | PAGE_WRITE;
+                                                       }
+
+else {
             ret = TLBRET_BADADDR;
         }
     }
@@ -278,7 +321,7 @@ int cpu_mips_handle_mmu_fault (CPUState
 #if 0
     log_cpu_state(env, 0);
 #endif
-    qemu_log("%s pc " TARGET_FMT_lx " ad " TARGET_FMT_lx " rw %d mmu_idx %d\n",
+    qemu_log("%s pc " TARGET_FMT_lx " ad(virtual+faulting) " TARGET_FMT_lx " rw %d mmu_idx %d\n",
               __func__, env->active_tc.PC, address, rw, mmu_idx);
 
     rw &= 1;
@@ -290,7 +333,7 @@ int cpu_mips_handle_mmu_fault (CPUState
     access_type = ACCESS_INT;
     ret = get_physical_address(env, &physical, &prot,
                                address, rw, access_type);
-    qemu_log("%s address=" TARGET_FMT_lx " ret %d physical " TARGET_FMT_plx " prot %d\n",
+    qemu_log("%s address(virtual+faulting)=" TARGET_FMT_lx " ret %d physical(ofFaulting) " TARGET_FMT_plx " prot %d\n",
               __func__, address, ret, physical, prot);
     if (ret == TLBRET_MATCH) {
         tlb_set_page(env, address & TARGET_PAGE_MASK,
@@ -397,7 +440,7 @@ static void set_hflags_for_handler (CPUS
 #endif
 
 void do_interrupt (CPUState *env)
-{
+{  //fprintf(stderr,"\n do_interrupt : qemu \n");
 #if !defined(CONFIG_USER_ONLY)
     target_ulong offset;
     int cause = -1;
@@ -469,6 +512,7 @@ void do_interrupt (CPUState *env)
         if (!(env->CP0_Status & (1 << CP0St_EXL)))
             env->CP0_Cause &= ~(1 << CP0Ca_BD);
         env->active_tc.PC = (int32_t)0xBFC00000;
+        //env->active_tc.PC = (int32_t)0xBFC30000;
         set_hflags_for_handler(env);
         break;
     case EXCP_EXT_INTERRUPT:
diff -rupN qemu-1.0.1/target-mips/helper.h modified_QEMU/target-mips/helper.h
--- qemu-1.0.1/target-mips/helper.h	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/target-mips/helper.h	2015-01-29 09:21:18.000000000 -0800
@@ -8,7 +8,12 @@ DEF_HELPER_3(ldl, tl, tl, tl, int)
 DEF_HELPER_3(ldr, tl, tl, tl, int)
 DEF_HELPER_3(sdl, void, tl, tl, int)
 DEF_HELPER_3(sdr, void, tl, tl, int)
+DEF_HELPER_2(v3mulu, tl, tl, tl)
+DEF_HELPER_2(vmulu, tl, tl, tl)
+DEF_HELPER_1(dpop, tl, tl)
 #endif
+DEF_HELPER_1(pop, tl, tl);
+
 DEF_HELPER_3(lwl, tl, tl, tl, int)
 DEF_HELPER_3(lwr, tl, tl, tl, int)
 DEF_HELPER_3(swl, void, tl, tl, int)
@@ -90,6 +95,11 @@ DEF_HELPER_0(dmfc0_tcschefback, tl)
 DEF_HELPER_0(dmfc0_lladdr, tl)
 DEF_HELPER_1(dmfc0_watchlo, tl, i32)
 #endif /* TARGET_MIPS64 */
+/* code adde by ayaz  */
+DEF_HELPER_0(mfc0_CvmCount,void) //
+
+
+
 
 DEF_HELPER_1(mtc0_index, void, tl)
 DEF_HELPER_1(mtc0_mvpcontrol, void, tl)
diff -rupN qemu-1.0.1/target-mips/mips-defs.h modified_QEMU/target-mips/mips-defs.h
--- qemu-1.0.1/target-mips/mips-defs.h	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/target-mips/mips-defs.h	2015-01-29 09:21:18.000000000 -0800
@@ -44,6 +44,7 @@
 #define		INSN_LOONGSON2E  0x20000000
 #define		INSN_LOONGSON2F  0x40000000
 #define		INSN_VR54XX	0x80000000
+#define		INSN_OCTEON	 0x10000000
 
 /* MIPS CPU defines. */
 #define		CPU_MIPS1	(ISA_MIPS1)
@@ -53,6 +54,7 @@
 #define		CPU_VR54XX	(CPU_MIPS4 | INSN_VR54XX)
 #define		CPU_LOONGSON2E  (CPU_MIPS3 | INSN_LOONGSON2E)
 #define		CPU_LOONGSON2F  (CPU_MIPS3 | INSN_LOONGSON2F)
+#define		CPU_OCTEON	(CPU_MIPS64R2 | INSN_OCTEON)
 
 #define		CPU_MIPS5	(CPU_MIPS4 | ISA_MIPS5)
 
diff -rupN qemu-1.0.1/target-mips/op_helper.c modified_QEMU/target-mips/op_helper.c
--- qemu-1.0.1/target-mips/op_helper.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/target-mips/op_helper.c	2015-01-29 09:21:18.000000000 -0800
@@ -19,7 +19,7 @@
 #include <stdlib.h>
 #include "cpu.h"
 #include "dyngen-exec.h"
-
+#include "qemu-timer.h" //added by ayaz
 #include "host-utils.h"
 
 #include "helper.h"
@@ -100,7 +100,7 @@ void helper_raise_exception (uint32_t ex
     helper_raise_exception_err(exception, 0);
 }
 
-#if !defined(CONFIG_USER_ONLY)
+/*#if !defined(CONFIG_USER_ONLY)
 static void do_restore_state (void *pc_ptr)
 {
     TranslationBlock *tb;
@@ -111,7 +111,7 @@ static void do_restore_state (void *pc_p
         cpu_restore_state(tb, env, pc);
     }
 }
-#endif
+#endif*/
 
 #if defined(CONFIG_USER_ONLY)
 #define HELPER_LD(name, insn, type)                                     \
@@ -320,7 +320,69 @@ void helper_dmultu (target_ulong arg1, t
 {
     mulu64(&(env->active_tc.LO[0]), &(env->active_tc.HI[0]), arg1, arg2);
 }
+static void addc(uint64_t res[], uint64_t a, int i)
+{
+    uint64_t c = res[i];
+    for (; i < 4; i++) {
+        res[i] = c + a;
+        if (res[i] < a) {
+            c = 1;
+            a = res[i+1];
+        } else
+              break;
+    }
+}
+target_ulong helper_v3mulu(target_ulong arg1, target_ulong arg2)
+{
+    uint64_t hi, lo, res[4];
+    int i;
+    for (i = 0; i < 4; i++) {
+        res[i] = 0;
+    }
+    mulu64(&res[0], &res[1], env->active_tc.MPL0, arg1);
+    mulu64(&lo, &hi, env->active_tc.MPL1, arg1);
+    res[1] = res[1] + lo;
+    if (res[1] < lo)
+        res[2]++;
+    res[2] = res[2] + hi;
+    if (res[2] < hi)
+        res[3]++;
+    mulu64(&lo, &hi, env->active_tc.MPL2, arg1);
+    res[2] = res[2] + lo;
+    if (res[2] < lo)
+        res[3]++;
+    res[3] = res[3] + hi;
+    addc(res, arg2, 0);
+    addc(res, env->active_tc.P0, 0);
+    addc(res, env->active_tc.P1, 1);
+    addc(res, env->active_tc.P2, 2);
+    env->active_tc.P0 = res[1];
+    env->active_tc.P1 = res[2];
+    env->active_tc.P2 = res[3];
+    return res[0];
+}
+target_ulong helper_vmulu(target_ulong arg1, target_ulong arg2)
+{
+    uint64_t hi, lo;
+    mulu64(&lo, &hi, env->active_tc.MPL0, arg1);
+    lo = lo + arg2;
+    if (lo < arg2)
+        hi++;
+    lo = lo + env->active_tc.P0;
+    if (lo < env->active_tc.P0)
+        hi++;
+    env->active_tc.P0 = hi;
+    return lo;
+}
+target_ulong helper_dpop(target_ulong arg)
+{
+    return ctpop64(arg);
+}
 #endif
+target_ulong helper_pop(target_ulong arg)
+{
+    return ctpop32((uint32_t)arg);
+}
 
 #ifndef CONFIG_USER_ONLY
 
@@ -1043,6 +1105,17 @@ target_ulong helper_mfc0_count (void)
 {
     return (int32_t)cpu_mips_get_count(env);
 }
+/* function given below is added by ayaz*
+ *
+ */
+void helper_mfc0_CvmCount (void)
+{   //printf("\n hello \n");
+        uint64_t val= cpu_get_ticks()/10;  //if not divided by 10 guest's timer's frequency appears to be 10
+       // times higher e.g. sleep 100 goes for 10 s real sleep
+
+	env->CP0_CvmCount=val;
+	//return cpu_get_ticks();
+}
 
 target_ulong helper_mftc0_entryhi(void)
 {
@@ -1583,9 +1656,12 @@ void helper_mtc0_status (target_ulong ar
 
 void helper_mttc0_status(target_ulong arg1)
 {
+	fprintf(stderr,"\n*******helper_mttc0_status***********\n");
     int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
     CPUState *other = mips_cpu_map_tc(&other_tc);
+	fprintf(stderr,"\n*******helper_mttc0_status***********\n");
 
+	fprintf(stderr,"\n*******status register in cp_helper.c=%lx***********\n",(unsigned long) other->CP0_Status);
     other->CP0_Status = arg1 & ~0xf1000018;
     sync_c0_status(other, other_tc);
 }
@@ -2292,10 +2368,10 @@ void helper_wait (void)
 
 #if !defined(CONFIG_USER_ONLY)
 
-static void do_unaligned_access (target_ulong addr, int is_write, int is_user, void *retaddr);
+//static void do_unaligned_access (target_ulong addr, int is_write, int is_user, void *retaddr);
 
 #define MMUSUFFIX _mmu
-#define ALIGNED_ONLY
+//#define ALIGNED_ONLY
 
 #define SHIFT 0
 #include "softmmu_template.h"
@@ -2309,12 +2385,13 @@ static void do_unaligned_access (target_
 #define SHIFT 3
 #include "softmmu_template.h"
 
-static void do_unaligned_access (target_ulong addr, int is_write, int is_user, void *retaddr)
+
+/*static void do_unaligned_access (target_ulong addr, int is_write, int is_user, void *retaddr)
 {
     env->CP0_BadVAddr = addr;
     do_restore_state (retaddr);
     helper_raise_exception ((is_write == 1) ? EXCP_AdES : EXCP_AdEL);
-}
+}*/
 
 void tlb_fill(CPUState *env1, target_ulong addr, int is_write, int mmu_idx,
               void *retaddr)
diff -rupN qemu-1.0.1/target-mips/translate.c modified_QEMU/target-mips/translate.c
--- qemu-1.0.1/target-mips/translate.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/target-mips/translate.c	2015-01-29 09:21:18.000000000 -0800
@@ -69,6 +69,11 @@ enum {
     OPC_JAL      = (0x03 << 26),
     OPC_JALS     = OPC_JAL | 0x5,
     OPC_BEQ      = (0x04 << 26),  /* Unconditional if rs = rt = 0 (B) */
+    /* Cavium Specific */
+    OPC_BBIT1    = (0x3a << 26),  /* jump on bit set, cavium specific */
+    OPC_BBIT132  = (0x3e << 26),  /* jump on bit set(for upper 32 bits) */
+    OPC_BBIT0    = (0x32 << 26),  /* jump on bit clear, cavium specific */
+    OPC_BBIT032  = (0x36 << 26),  /* jump on bit clear(for upper 32 bits) */
     OPC_BEQL     = (0x14 << 26),
     OPC_BNE      = (0x05 << 26),
     OPC_BNEL     = (0x15 << 26),
@@ -78,6 +83,11 @@ enum {
     OPC_BGTZL    = (0x17 << 26),
     OPC_JALX     = (0x1D << 26),  /* MIPS 16 only */
     OPC_JALXS    = OPC_JALX | 0x5,
+    /*Cavium Specific Branches*/
+    //OPC_BBIT1    = (0x3a << 26),  /* jump on bit set */
+    //OPC_BBIT132  = (0x3e << 26),  /* jump on bit set (for upper 32 bits) */
+    //OPC_BBIT0    = (0x32 << 26),  /* jump on bit clear */
+    //OPC_BBIT032  = (0x36 << 26),  /* jump on bit clear (for upper 32 bits) */
     /* Load and stores */
     OPC_LDL      = (0x1A << 26),
     OPC_LDR      = (0x1B << 26),
@@ -264,6 +274,32 @@ enum {
     OPC_MADD     = 0x00 | OPC_SPECIAL2,
     OPC_MADDU    = 0x01 | OPC_SPECIAL2,
     OPC_MUL      = 0x02 | OPC_SPECIAL2,
+    /* Cavium Specific Instructions 
+    OPC_BADDU    = 0x28 | OPC_SPECIAL2,
+    OPC_DMUL     = 0x03 | OPC_SPECIAL2,
+    OPC_EXTS     = 0x3a | OPC_SPECIAL2,
+    OPC_EXTS32   = 0x3b | OPC_SPECIAL2,
+    OPC_CINS     = 0x32 | OPC_SPECIAL2,
+    OPC_CINS32   = 0x33 | OPC_SPECIAL2,
+    OPC_SEQI     = 0x2e | OPC_SPECIAL2,
+    OPC_SNEI     = 0x2f | OPC_SPECIAL2,
+    OPC_MTM0     = 0x08 | OPC_SPECIAL2,
+    OPC_MTM1     = 0x0c | OPC_SPECIAL2,
+    OPC_MTM2     = 0x0d | OPC_SPECIAL2,
+    OPC_MTP0     = 0x09 | OPC_SPECIAL2,
+    OPC_MTP1     = 0x0a | OPC_SPECIAL2,
+    OPC_MTP2     = 0x0b | OPC_SPECIAL2,
+    OPC_V3MULU   = 0x11 | OPC_SPECIAL2,
+    OPC_VMM0     = 0x10 | OPC_SPECIAL2,
+    OPC_VMULU    = 0x0f | OPC_SPECIAL2,
+    OPC_POP      = 0X2C | OPC_SPECIAL2,
+    OPC_DPOP     = 0X2D | OPC_SPECIAL2,
+    OPC_SEQ      = 0x2a | OPC_SPECIAL2,
+    OPC_SNE      = 0x2b | OPC_SPECIAL2,
+    OPC_SAA      = 0x18 | OPC_SPECIAL2,
+    OPC_SAAD     = 0x19 | OPC_SPECIAL2,
+*/
+/**************************************/
     OPC_MSUB     = 0x04 | OPC_SPECIAL2,
     OPC_MSUBU    = 0x05 | OPC_SPECIAL2,
     /* Loongson 2F */
@@ -286,6 +322,31 @@ enum {
     OPC_DCLO     = 0x25 | OPC_SPECIAL2,
     /* Special */
     OPC_SDBBP    = 0x3F | OPC_SPECIAL2,
+
+    /* Cavium Specific Instructions */
+    OPC_BADDU    = 0x28 | OPC_SPECIAL2,
+    OPC_DMUL     = 0x03 | OPC_SPECIAL2,
+    OPC_EXTS     = 0x3a | OPC_SPECIAL2,
+    OPC_EXTS32   = 0x3b | OPC_SPECIAL2,
+    OPC_CINS     = 0x32 | OPC_SPECIAL2,
+    OPC_CINS32   = 0x33 | OPC_SPECIAL2,
+    OPC_SEQI     = 0x2e | OPC_SPECIAL2,
+    OPC_SNEI     = 0x2f | OPC_SPECIAL2,
+    OPC_MTM0     = 0x08 | OPC_SPECIAL2,
+    OPC_MTM1     = 0x0c | OPC_SPECIAL2,
+    OPC_MTM2     = 0x0d | OPC_SPECIAL2,
+    OPC_MTP0     = 0x09 | OPC_SPECIAL2,
+    OPC_MTP1     = 0x0a | OPC_SPECIAL2,
+    OPC_MTP2     = 0x0b | OPC_SPECIAL2,
+    OPC_V3MULU   = 0x11 | OPC_SPECIAL2,
+    OPC_VMM0     = 0x10 | OPC_SPECIAL2,
+    OPC_VMULU    = 0x0f | OPC_SPECIAL2,
+    OPC_POP      = 0X2C | OPC_SPECIAL2,
+    OPC_DPOP     = 0X2D | OPC_SPECIAL2,
+    OPC_SEQ      = 0x2a | OPC_SPECIAL2,
+    OPC_SNE      = 0x2b | OPC_SPECIAL2,
+    OPC_SAA      = 0x18 | OPC_SPECIAL2,
+    OPC_SAAD     = 0x19 | OPC_SPECIAL2,
 };
 
 /* Special3 opcodes */
@@ -482,7 +543,7 @@ enum {
 static TCGv_ptr cpu_env;
 static TCGv cpu_gpr[32], cpu_PC;
 static TCGv cpu_HI[MIPS_DSP_ACC], cpu_LO[MIPS_DSP_ACC], cpu_ACX[MIPS_DSP_ACC];
-static TCGv cpu_dspctrl, btarget, bcond;
+static TCGv cpu_dspctrl, btarget, bcond, mpl0, mpl1, mpl2, p0, p1, p2;
 static TCGv_i32 hflags;
 static TCGv_i32 fpu_fcr0, fpu_fcr31;
 
@@ -762,7 +823,9 @@ generate_exception_err (DisasContext *ct
 
 static inline void
 generate_exception (DisasContext *ctx, int excp)
-{
+{ // fprintf(stderr,"\n __________EXCP __________ : %d \n",excp);
+   if(excp == EXCP_SYSCALL)
+    // fprintf(stderr,"\n _________ syscall  _________  : %d  \n", excp);
     save_cpu_state(ctx, 1);
     gen_helper_0i(raise_exception, excp);
 }
@@ -1582,6 +1645,83 @@ static void gen_shift_imm(CPUState *env,
     MIPS_DEBUG("%s %s, %s, " TARGET_FMT_lx, opn, regnames[rt], regnames[rs], uimm);
     tcg_temp_free(t0);
 }
+#if defined(TARGET_MIPS64)
+static void gen_LMI (CPUMIPSState *env, DisasContext *ctx, uint32_t opc,
+                     int rs, int rt, int rd)
+{
+    const char *opn = "LMI";
+    TCGv t0, t1;
+    t0 = tcg_temp_new();
+    t1 = tcg_temp_new();
+    gen_load_gpr(t0, rs);
+    gen_load_gpr(t1, rt);
+    switch (opc) {
+    case OPC_MTM0:
+        tcg_gen_mov_tl(mpl0, t0);
+        tcg_gen_movi_tl(p0, 0);
+        tcg_gen_movi_tl(p1, 0);
+        tcg_gen_movi_tl(p2, 0);
+        opn = "mtm0";
+        break;
+    case OPC_MTM1:
+        tcg_gen_mov_tl(mpl1, t0);
+        tcg_gen_movi_tl(p0, 0);
+        tcg_gen_movi_tl(p1, 0);
+        tcg_gen_movi_tl(p2, 0);
+        opn = "mtm1";
+        break;
+    case OPC_MTM2:
+        tcg_gen_mov_tl(mpl2, t0);
+        tcg_gen_movi_tl(p0, 0);
+        tcg_gen_movi_tl(p1, 0);
+        tcg_gen_movi_tl(p2, 0);
+        opn = "mtm2";
+        break;
+    case OPC_MTP0:
+        tcg_gen_mov_tl(p0, t0);
+        opn = "mtp0";
+        break;
+    case OPC_MTP1:
+        tcg_gen_mov_tl(p1, t0);
+        opn = "mtp1";
+        break;
+    case OPC_MTP2:
+        tcg_gen_mov_tl(p2, t0);
+        opn = "mtp2";
+        break;
+    case OPC_VMM0:
+        tcg_gen_mul_i64(t0, t0, mpl0);
+        tcg_gen_add_tl(t1, t1, t0);
+        tcg_gen_add_tl(t1, t1, p0);
+        gen_store_gpr(t1, rd);
+        tcg_gen_mov_tl(mpl0, t1);
+        tcg_gen_movi_tl(p0, 0);
+        tcg_gen_movi_tl(p1, 0);
+        tcg_gen_movi_tl(p2, 0);
+        opn = "vmm0";
+        break;
+    case OPC_VMULU:
+        gen_helper_vmulu(t0, t0, t1);
+        gen_store_gpr(t0, rd);
+        opn = "vmulu";
+        break;
+    case OPC_V3MULU:
+        gen_load_gpr(t0, rs);
+        gen_load_gpr(t1, rt);
+        gen_helper_v3mulu(t0, t0, t1);
+        gen_store_gpr(t0, rd);
+        opn = "v3mulu";
+        break;
+    }
+    (void)opn; /* avoid a compiler warning */
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+#endif
+
+
+
+
 
 /* Arithmetic */
 static void gen_arith (CPUState *env, DisasContext *ctx, uint32_t opc,
@@ -1748,6 +1888,31 @@ static void gen_arith (CPUState *env, Di
         }
         opn = "dsubu";
         break;
+        case OPC_BADDU:
+       {
+                    TCGv t0 = tcg_temp_new();
+                    TCGv t1 = tcg_temp_new();
+                    gen_load_gpr(t0, rs);
+                    gen_load_gpr(t1, rt);
+                    tcg_gen_add_tl(t0, t1, t0);
+                    tcg_gen_ext8u_tl(t0, t0);
+                    gen_store_gpr(t0, rd);
+                    tcg_temp_free(t0);
+                    tcg_temp_free(t1);
+                }
+               opn = "baddu";
+               break;
+            case OPC_DMUL:
+                {
+                    TCGv t0 = tcg_temp_new();
+                    TCGv t1 = tcg_temp_new();
+                    gen_load_gpr(t0, rs);
+                    gen_load_gpr(t1, rt);
+                    tcg_gen_mul_i64(cpu_gpr[rd], t0, t1);
+                }
+                    opn = "dmul";
+                    break;
+
 #endif
     case OPC_MUL:
         if (likely(rs != 0 && rt != 0)) {
@@ -2013,6 +2178,154 @@ static void gen_HILO (DisasContext *ctx,
     MIPS_DEBUG("%s %s", opn, regnames[reg]);
 }
 
+#if defined(TARGET_MIPS64)
+static void gen_seqsne (DisasContext *ctx, uint32_t opc,
+                        int rd, int rs, int rt)
+{
+    const char *opn = "seq/sne";
+    TCGv t0, t1;
+    t0 = tcg_temp_new();
+    t1 = tcg_temp_new();
+    gen_load_gpr(t0, rs);
+    gen_load_gpr(t1, rt);
+    switch (opc) {
+    case OPC_SEQ:
+        tcg_gen_xor_tl(t0, t0, t1);
+        tcg_gen_setcondi_tl(TCG_COND_LTU, cpu_gpr[rd], t0, 1);
+        opn = "seq";
+        break;
+    case OPC_SNE:
+        tcg_gen_xor_tl(t0, t0, t1);
+        tcg_gen_setcondi_tl(TCG_COND_GTU, cpu_gpr[rd], t0, 0);
+        opn = "sne";
+        break;
+    default:
+        MIPS_INVAL(opn);
+        generate_exception(ctx, EXCP_RI);
+        goto out;
+    }
+
+    (void)opn; /* avoid a compiler warning */
+out:
+        tcg_temp_free(t0);
+        tcg_temp_free(t1);
+
+}
+
+static void gen_exts (CPUState *env, DisasContext *ctx, uint32_t opc, int rt,
+                      int rs, int lsb, int msb)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new();
+    target_ulong mask;
+    gen_load_gpr(t1, rs);
+    switch (opc) {
+    case OPC_EXTS:
+        tcg_gen_shri_tl(t0, t1, lsb);
+        tcg_gen_andi_tl(t0, t0, (1ULL << (msb + 1)) - 1);
+        /* To sign extened the remaining bits according to
+           the msb of the bit field */
+        mask = 1ULL << msb;
+        tcg_gen_andi_tl(t1, t0, mask);
+        tcg_gen_addi_tl(t1, t1, -1);
+        tcg_gen_orc_tl(t0, t0, t1);
+        gen_store_gpr(t0, rt);
+        break;
+    case OPC_EXTS32:
+        tcg_gen_shri_tl(t0, t1, lsb + 32);
+        tcg_gen_andi_tl(t0, t0, (1ULL << (msb + 1)) - 1);
+        mask = 1ULL << msb;
+        tcg_gen_andi_tl(t1, t0, mask);
+        tcg_gen_addi_tl(t1, t1, -1);
+        tcg_gen_orc_tl(t0, t0, t1);
+        gen_store_gpr(t0, rt);
+        break;
+
+    }
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static void gen_saa (CPUState *env, DisasContext *ctx, uint32_t opc,
+                     int rt, int base)
+{
+    const char *opn = "saa";
+    TCGv t0, t1, temp;
+    t0 = tcg_temp_new();
+    t1 = tcg_temp_new();
+    temp = tcg_temp_new();
+    gen_load_gpr(t1, rt);
+    gen_base_offset_addr(ctx, t0, base, 0);
+    switch (opc) {
+    case OPC_SAA:
+        save_cpu_state(ctx, 1);
+        op_ld_lw(temp, t0, ctx);
+        tcg_gen_add_tl(temp, temp, t1);
+        op_st_sw(temp, t0, ctx);
+        opn = "saa";
+        break;
+    case OPC_SAAD:
+        save_cpu_state(ctx, 0);
+        op_ld_ld(temp, t0, ctx);
+        tcg_gen_add_tl(temp, temp, t1);
+        op_st_sd(temp, t0, ctx);
+        opn = "saad";
+        break;
+    }
+
+    (void)opn; /* avoid a compiler warning */
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static void gen_pop_count (DisasContext *ctx, uint32_t opc, int rd, int rs)
+{
+    const char *opn = "pop";
+    TCGv t0;
+    t0 = tcg_temp_new();
+    gen_load_gpr(t0, rs);
+    switch (opc) {
+    case OPC_DPOP:
+        gen_helper_dpop(t0, t0);
+        gen_store_gpr(t0, rd);
+        opn = "dpop";
+        break;
+    case OPC_POP:
+        gen_helper_pop(t0, t0);
+        gen_store_gpr(t0, rd);
+        opn = "pop";
+        break;
+    }
+    (void)opn; /* avoid a compiler warning */
+    tcg_temp_free(t0);
+}
+
+static void gen_set_imm(CPUState *env, uint32_t opc,
+                        int rt, int rs, int16_t imm)
+{
+    TCGv t0;
+    const char *opn = "imm set";
+    t0 = tcg_temp_new();
+    gen_load_gpr(t0, rs);
+    switch (opc) {
+    case OPC_SEQI:
+        tcg_gen_xori_tl(t0, t0, imm);
+        tcg_gen_setcondi_tl(TCG_COND_LT, cpu_gpr[rt], t0, 1);
+        opn = "seqi";
+        break;
+    case OPC_SNEI:
+        tcg_gen_xori_tl(t0, t0, imm);
+        tcg_gen_setcondi_tl(TCG_COND_GT, cpu_gpr[rt], t0, 0);
+        opn = "snei";
+        break;
+    }
+    (void)opn; /* avoid a compiler warning */
+    tcg_temp_free(t0);
+}
+
+#endif
+
 static void gen_muldiv (DisasContext *ctx, uint32_t opc,
                         int rs, int rt)
 {
@@ -2704,6 +3017,7 @@ static void gen_compute_branch (DisasCon
     target_ulong btgt = -1;
     int blink = 0;
     int bcond_compute = 0;
+    //target_ulong maskb; /* Used in BBIT0 and BBIT1 */
     TCGv t0 = tcg_temp_new();
     TCGv t1 = tcg_temp_new();
 
@@ -2729,6 +3043,31 @@ static void gen_compute_branch (DisasCon
         }
         btgt = ctx->pc + insn_bytes + offset;
         break;
+
+    case OPC_BBIT0:
+    case OPC_BBIT1:
+        {   
+           // fprintf(stderr,"\n[QEMU] Executing BBIT0/1 from gen_compute\n");
+            target_ulong maskb;
+            gen_load_gpr(t0, rs);
+            maskb = 1ULL << rt;
+            tcg_gen_andi_tl(t0, t0, maskb);
+            bcond_compute = 1;
+            btgt = ctx->pc + insn_bytes + offset;
+            break;
+        }
+    case OPC_BBIT032:
+    case OPC_BBIT132:
+        {
+            target_ulong maskb;
+            gen_load_gpr(t0, rs);
+            maskb = 1ULL << (rt + 32);
+            tcg_gen_andi_tl(t0, t0, maskb);
+            bcond_compute = 1;
+            btgt = ctx->pc + insn_bytes + offset;
+            break;
+        }
+
     case OPC_BGEZ:
     case OPC_BGEZAL:
     case OPC_BGEZALS:
@@ -2887,6 +3226,16 @@ static void gen_compute_branch (DisasCon
             MIPS_DEBUG("bne %s, %s, " TARGET_FMT_lx,
                        regnames[rs], regnames[rt], btgt);
             goto not_likely;
+
+        case OPC_BBIT1:
+        case OPC_BBIT132:
+            tcg_gen_setcondi_tl(TCG_COND_NE, bcond, t0, 0);
+            goto not_likely;
+        case OPC_BBIT0:
+        case OPC_BBIT032:
+            tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, t0, 0);
+            goto not_likely;
+
         case OPC_BNEL:
             tcg_gen_setcond_tl(TCG_COND_NE, bcond, t0, t1);
             MIPS_DEBUG("bnel %s, %s, " TARGET_FMT_lx,
@@ -3032,7 +3381,7 @@ static void gen_bitops (DisasContext *ct
         break;
 #if defined(TARGET_MIPS64)
     case OPC_DINSM:
-        if (lsb > msb)
+        if (lsb > (msb+32))
             goto fail;
         mask = ((msb - lsb + 1 + 32 < 64) ? ((1ULL << (msb - lsb + 1 + 32)) - 1) : ~0ULL) << lsb;
         gen_load_gpr(t0, rt);
@@ -3062,6 +3411,22 @@ static void gen_bitops (DisasContext *ct
         tcg_gen_andi_tl(t1, t1, mask);
         tcg_gen_or_tl(t0, t0, t1);
         break;
+    case OPC_CINS:
+        mask =  (1ULL << (msb+1))-1;
+        gen_load_gpr(t0, rt);
+        tcg_gen_andi_tl(t0, t0, 0);
+        tcg_gen_andi_tl(t1, t1, mask);
+        tcg_gen_shli_tl(t1, t1, lsb);
+        tcg_gen_or_tl(t0, t0, t1);
+        break;
+    case OPC_CINS32:
+        mask =  (1ULL << (msb+1))-1;
+        gen_load_gpr(t0, rt);
+        tcg_gen_andi_tl(t0, t0, 0);
+        tcg_gen_andi_tl(t1, t1, mask);
+        tcg_gen_shli_tl(t1, t1, (lsb+32));
+        tcg_gen_or_tl(t0, t0, t1);
+        break;  
 #endif
     default:
 fail:
@@ -3445,7 +3810,7 @@ static void gen_mfc0 (CPUState *env, Dis
     case 12:
         switch (sel) {
         case 0:
-            gen_mfc0_load32(arg, offsetof(CPUState, CP0_Status));
+        	gen_mfc0_load32(arg, offsetof(CPUState, CP0_Status));
             rn = "Status";
             break;
         case 1:
@@ -4576,7 +4941,7 @@ static void gen_dmfc0 (CPUState *env, Di
     case 9:
         switch (sel) {
         case 0:
-            /* Mark as an IO operation because we read the time.  */
+        	/* Mark as an IO operation because we read the time.  */
             if (use_icount)
                 gen_io_start();
             gen_helper_mfc0_count(arg);
@@ -4588,6 +4953,30 @@ static void gen_dmfc0 (CPUState *env, Di
             ctx->bstate = BS_STOP;
             rn = "Count";
             break;
+        case 6:
+        	  // env->CP0_CvmCount=cpu_get_ticks();
+        	//printf("\n reading CvmCount:0x%lx \n ",env->CP0_CvmCount);
+        	//tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUState, CP0_CvmCount));
+        	/* if (use_icount)
+        	                gen_io_start();
+        	            gen_helper_mfc0_count(arg);
+        	            if (use_icount) {
+        	                gen_io_end();
+        	            }
+        	            /* Break the TB to be able to take timer interrupts immediately
+        	               after reading count.  */
+        	            //ctx->bstate = BS_STOP;
+        	            //rn = "Count";
+        	            //break;  */
+        	tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUState, CP0_CvmCount));
+        	gen_helper_mfc0_CvmCount();
+
+        	rn = "CvmCount";
+            break;
+        case 7:
+            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUState, CP0_CvmCtl));
+            rn = "CvmCtl";
+            break;
         /* 6,7 are implementation dependent */
         default:
             goto die;
@@ -4609,6 +4998,10 @@ static void gen_dmfc0 (CPUState *env, Di
             gen_mfc0_load32(arg, offsetof(CPUState, CP0_Compare));
             rn = "Compare";
             break;
+        case 7:
+            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUState, CP0_CvmMemCtl));
+            rn = "CvmMemCtl";
+            break;
         /* 6,7 are implementation dependent */
         default:
             goto die;
@@ -4842,8 +5235,14 @@ static void gen_dmfc0 (CPUState *env, Di
         break;
     case 27:
         switch (sel) {
+	case 0://Cavium specific ICacheError
+	    //printf("\n Reading CP0_ICacheErr Reg...");
+            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUState, CP0_ICacheErr));
+            rn = "ICacheErr";
+            break;
+
         /* ignored */
-        case 0 ... 3:
+        case 1 ... 3:
             tcg_gen_movi_tl(arg, 0); /* unimplemented */
             rn = "CacheErr";
             break;
@@ -5145,6 +5544,14 @@ static void gen_dmtc0 (CPUState *env, Di
             gen_helper_mtc0_count(arg);
             rn = "Count";
             break;
+        case 6:
+            gen_helper_mtc0_count(arg);
+            rn = "CvmCount";
+            break;
+        case 7:
+            tcg_gen_st_tl(arg, cpu_env, offsetof(CPUState, CP0_CvmCtl));
+            rn = "CvmCtl";
+            break;
         /* 6,7 are implementation dependent */
         default:
             goto die;
@@ -5168,6 +5575,10 @@ static void gen_dmtc0 (CPUState *env, Di
             gen_helper_mtc0_compare(arg);
             rn = "Compare";
             break;
+        case 7:
+            tcg_gen_st_tl(arg, cpu_env, offsetof(CPUState, CP0_CvmMemCtl));
+            rn = "CvmMemCtl";
+            break;
         /* 6,7 are implementation dependent */
         default:
             goto die;
@@ -5432,7 +5843,12 @@ static void gen_dmtc0 (CPUState *env, Di
         break;
     case 27:
         switch (sel) {
-        case 0 ... 3:
+	case 0://Cavium specific ICache error
+            tcg_gen_st_tl(arg, cpu_env, offsetof(CPUState, CP0_ICacheErr));
+            rn = "ICacheErr";
+            break;
+    
+        case 1 ... 3:
             /* ignored */
             rn = "CacheErr";
             break;
@@ -10306,7 +10722,7 @@ static void gen_pool32axf (CPUState *env
         case SYNC:
             /* NOP */
             break;
-        case SYSCALL:
+        case SYSCALL:  printf(" \n >>>>>>>>><<<<<<< A Syscall   >>>>>>>>>>>><<<<<<<<<<  \n");           
             generate_exception(ctx, EXCP_SYSCALL);
             ctx->bstate = BS_STOP;
             break;
@@ -10767,11 +11183,15 @@ static void decode_micromips32_opc (CPUS
         case CACHE:
             /* Treat as no-op. */
             break;
-        case LWC2:
-        case SWC2:
-            /* COP2: Not implemented. */
-            generate_exception_err(ctx, EXCP_CpU, 2);
+        case OPC_LWC2: /* BBIT0 */
+        case OPC_LDC2: /* BBIT032 */
+        case OPC_SWC2: /* BBIT1 */
+        case OPC_SDC2: /* BBIT132 */
+             if (env->insn_flags & INSN_OCTEON) {
+            	 gen_compute_branch(ctx, op, 4, rs, rt, imm << 2);
+                 *is_branch = 1;
             break;
+                }
         case LWP:
         case SWP:
 #ifdef TARGET_MIPS64
@@ -11694,7 +12114,10 @@ static void decode_opc (CPUState *env, D
     int32_t offset;
     int rs, rt, rd, sa;
     uint32_t op, op1, op2;
-    int16_t imm;
+    int16_t imm, imm10;
+
+
+
 
     /* make sure instructions are on a word boundary */
     if (ctx->pc & 0x3) {
@@ -11723,6 +12146,8 @@ static void decode_opc (CPUState *env, D
     rd = (ctx->opcode >> 11) & 0x1f;
     sa = (ctx->opcode >> 6) & 0x1f;
     imm = (int16_t)ctx->opcode;
+    /* 10 bit Immediate value For SEQI,SNEI */
+      imm10 = (ctx->opcode >> 6) & 0x3ff;
     switch (op) {
     case OPC_SPECIAL:
         op1 = MASK_SPECIAL(ctx->opcode);
@@ -11948,6 +12373,60 @@ static void decode_opc (CPUState *env, D
         case OPC_MUL:
             gen_arith(env, ctx, op1, rd, rs, rt);
             break;
+
+#if defined(TARGET_MIPS64)
+
+        case OPC_DMUL:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_arith(env, ctx, op1, rd, rs, rt);
+            break;
+        case OPC_CINS:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_bitops(ctx, op1, rt, rs, sa, rd);
+            break;
+        case OPC_CINS32:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_bitops(ctx, op1, rt, rs, sa, rd);
+            break;
+        case OPC_MTM0:
+        case OPC_MTM1:
+        case OPC_MTM2:
+        case OPC_MTP0:
+        case OPC_MTP1:
+        case OPC_MTP2:
+        case OPC_VMULU:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_LMI(env, ctx, op1, rs, rt, rd);
+            break;
+        case OPC_BADDU:
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_arith(env, ctx, op1, rd, rs, rt);
+            break;
+
+        case OPC_EXTS:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_exts(env, ctx, op1, rt, rs, sa, rd);
+            break;
+        case OPC_EXTS32:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_exts(env, ctx, op1, rt, rs, sa, rd);
+            break;
+        case OPC_SAA:
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_saa(env, ctx, op1, rt, rs);
+            break;
+        case OPC_SAAD:
+            check_insn(env, ctx, INSN_OCTEON);
+            check_mips_64(ctx);
+            gen_saa(env, ctx, op1, rt, rs);
+            break;
+#endif
         case OPC_CLO:
         case OPC_CLZ:
             check_insn(env, ctx, ISA_MIPS32);
@@ -11967,13 +12446,24 @@ static void decode_opc (CPUState *env, D
             break;
         case OPC_DIV_G_2F:
         case OPC_DIVU_G_2F:
-        case OPC_MULT_G_2F:
         case OPC_MULTU_G_2F:
         case OPC_MOD_G_2F:
         case OPC_MODU_G_2F:
             check_insn(env, ctx, INSN_LOONGSON2F);
             gen_loongson_integer(ctx, op1, rd, rs, rt);
             break;
+        case OPC_MULT_G_2F:
+            if (!(env->insn_flags & CPU_OCTEON)) {
+                check_insn(env, ctx, INSN_LOONGSON2F);
+                gen_loongson_integer(ctx, op1, rd, rs, rt);
+            } else {
+#if defined(TARGET_MIPS64)
+                /* Cavium Specific vmm0 */
+                check_mips_64(ctx);
+                gen_LMI(env, ctx, op1, rs, rt, rd);
+#endif
+            }
+            break;
 #if defined(TARGET_MIPS64)
         case OPC_DCLO:
         case OPC_DCLZ:
@@ -11981,7 +12471,6 @@ static void decode_opc (CPUState *env, D
             check_mips_64(ctx);
             gen_cl(ctx, op1, rd, rs);
             break;
-        case OPC_DMULT_G_2F:
         case OPC_DMULTU_G_2F:
         case OPC_DDIV_G_2F:
         case OPC_DDIVU_G_2F:
@@ -11990,7 +12479,44 @@ static void decode_opc (CPUState *env, D
             check_insn(env, ctx, INSN_LOONGSON2F);
             gen_loongson_integer(ctx, op1, rd, rs, rt);
             break;
+        case OPC_DMULT_G_2F:
+            if (!(env->insn_flags & CPU_OCTEON)) {
+                check_insn(env, ctx, INSN_LOONGSON2F);
+                gen_loongson_integer(ctx, op1, rd, rs, rt);
+            } else {
+                /* Cavium Specific instruction v3mulu */
+                check_mips_64(ctx);
+                gen_LMI(env, ctx, op1, rs, rt, rd);
+            }
+            break;
+
+        case OPC_SEQ:
+        case OPC_SNE:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_seqsne(ctx, op1, rd, rs, rt);
+            break;
+        case OPC_SEQI:
+        case OPC_SNEI:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_set_imm(env, op1, rt, rs, imm10);
+            break;
+        case OPC_POP:
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_pop_count(ctx, op1, rd, rs);
+            break;
+
+        case OPC_DPOP:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_pop_count(ctx, op1, rd, rs);
+            break;
+
 #endif
+
+
+
         default:            /* Invalid */
             MIPS_INVAL("special2");
             generate_exception(ctx, EXCP_RI);
@@ -12063,6 +12589,37 @@ static void decode_opc (CPUState *env, D
             check_insn(env, ctx, INSN_LOONGSON2E);
             gen_loongson_integer(ctx, op1, rd, rs, rt);
             break;
+        case OPC_DMULT_G_2F:
+            if (!(env->insn_flags & CPU_OCTEON)) {
+                check_insn(env, ctx, INSN_LOONGSON2F);
+                gen_loongson_integer(ctx, op1, rd, rs, rt);
+            } else {
+                /* Cavium Specific instruction v3mulu */
+                check_mips_64(ctx);
+                gen_LMI(env, ctx, op1, rs, rt, rd);
+            }
+            break;
+        case OPC_SEQ:
+        case OPC_SNE:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_seqsne(ctx, op1, rd, rs, rt);
+            break;
+        case OPC_SEQI:
+        case OPC_SNEI:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_set_imm(env, op1, rt, rs, imm10);
+            break;
+        case OPC_POP:
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_pop_count(ctx, op1, rd, rs);
+            break;
+        case OPC_DPOP:
+            check_mips_64(ctx);
+            check_insn(env, ctx, INSN_OCTEON);
+            gen_pop_count(ctx, op1, rd, rs);
+            break;
 #endif
         default:            /* Invalid */
             MIPS_INVAL("special3");
@@ -12141,6 +12698,7 @@ static void decode_opc (CPUState *env, D
                     gen_store_gpr(t0, rt);
                     break;
                 case OPC_DI:
+                	//printf("\n Disable Interrupt");
                     check_insn(env, ctx, ISA_MIPS32R2);
                     save_cpu_state(ctx, 1);
                     gen_helper_di(t0);
@@ -12149,6 +12707,7 @@ static void decode_opc (CPUState *env, D
                     ctx->bstate = BS_STOP;
                     break;
                 case OPC_EI:
+                	//printf("\n Enable Interrupt");
                     check_insn(env, ctx, ISA_MIPS32R2);
                     save_cpu_state(ctx, 1);
                     gen_helper_ei(t0);
@@ -12281,10 +12840,21 @@ static void decode_opc (CPUState *env, D
         break;
 
     /* COP2.  */
-    case OPC_LWC2:
-    case OPC_LDC2:
-    case OPC_SWC2:
-    case OPC_SDC2:
+        /* COP2.  */
+        /* Conflicting opcodes with Cavium specific branch instructions
+           if cpu_model is set to Octeon these opcodes will
+       	   belong to INSN_OCTEON */
+        case OPC_LWC2: /* BBIT0 */
+        case OPC_LDC2: /* BBIT032 */
+        case OPC_SWC2: /* BBIT1 */
+        case OPC_SDC2: /* BBIT132 */
+             // Following if line and its closing } needs to comment if 
+             // we want QEMU to put just one instruction in a TB
+            //if (env->insn_flags & INSN_OCTEON) {
+                gen_compute_branch(ctx, op, 4, rs, rt, imm << 2);
+                *is_branch = 1;
+                break;
+            //}
     case OPC_CP2:
         /* COP2: Not implemented. */
         generate_exception_err(ctx, EXCP_CpU, 2);
@@ -12388,6 +12958,7 @@ gen_intermediate_code_internal (CPUState
     int max_insns;
     int insn_bytes;
     int is_branch;
+    int i;
 
     if (search_pc)
         qemu_log("search pc %d\n", search_pc);
@@ -12413,7 +12984,7 @@ gen_intermediate_code_internal (CPUState
         max_insns = CF_COUNT_MASK;
     LOG_DISAS("\ntb %p idx %d hflags %04x\n", tb, ctx.mem_idx, ctx.hflags);
     gen_icount_start();
-    while (ctx.bstate == BS_NONE) {
+    for (i=0; i<1;i++) { //while (ctx.bstate == BS_NONE) {
         if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
             QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
                 if (bp->pc == ctx.pc) {
@@ -12673,6 +13244,18 @@ static void mips_tcg_init(void)
     cpu_dspctrl = tcg_global_mem_new(TCG_AREG0,
                                      offsetof(CPUState, active_tc.DSPControl),
                                      "DSPControl");
+    mpl0 = tcg_global_mem_new(TCG_AREG0,
+                              offsetof(CPUState, active_tc.MPL0), "MPL0");
+    mpl1 = tcg_global_mem_new(TCG_AREG0,
+                              offsetof(CPUState, active_tc.MPL1), "MPL1");
+    mpl2 = tcg_global_mem_new(TCG_AREG0,
+                              offsetof(CPUState, active_tc.MPL2), "MPL2");
+    p0 = tcg_global_mem_new(TCG_AREG0,
+                            offsetof(CPUState, active_tc.P0), "P0");
+    p1 = tcg_global_mem_new(TCG_AREG0,
+                            offsetof(CPUState, active_tc.P1), "P1");
+    p2 = tcg_global_mem_new(TCG_AREG0,
+                            offsetof(CPUState, active_tc.P2), "P2");
     bcond = tcg_global_mem_new(TCG_AREG0,
                                offsetof(CPUState, bcond), "bcond");
     btarget = tcg_global_mem_new(TCG_AREG0,
@@ -12779,6 +13362,7 @@ void cpu_reset (CPUMIPSState *env)
         env->hflags |= MIPS_HFLAG_FPU;
     }
 #ifdef TARGET_MIPS64
+    env->hflags |=  MIPS_HFLAG_UX;
     if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {
         env->hflags |= MIPS_HFLAG_F64;
     }
diff -rupN qemu-1.0.1/target-mips/translate_init.c modified_QEMU/target-mips/translate_init.c
--- qemu-1.0.1/target-mips/translate_init.c	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/target-mips/translate_init.c	2015-01-29 09:21:18.000000000 -0800
@@ -87,6 +87,7 @@ struct mips_def_t {
     int32_t CP0_SRSConf4_rw_bitmask;
     int32_t CP0_SRSConf4;
     int insn_flags;
+    target_ulong CP0_CvmCtl, CP0_CvmMemCtl,CP0_CvmCount, CP0_ICacheErr;
     enum mips_mmu_types mmu_type;
 };
 
@@ -450,6 +451,64 @@ static const mips_def_t mips_defs[] =
         .insn_flags = CPU_MIPS64R2 | ASE_MIPS3D,
         .mmu_type = MMU_TYPE_R4000,
     },
+
+    {
+                /* XXX: We will add some more features related to
+                   Octeon's coprocessors */
+                .name = "octeon",
+                .CP0_PRid = 0xd0408,
+                .CP0_Config0 = MIPS_CONFIG0 | (0x1 << CP0C0_AR) | (0x2 << CP0C0_AT) |
+                (MMU_TYPE_R4000 << CP0C0_MT),
+                .CP0_Config1 = MIPS_CONFIG1 | (63 << CP0C1_MMU) |
+                (2 << CP0C1_IS) | (4 << CP0C1_IL) | (3 << CP0C1_IA) |
+                (2 << CP0C1_DS) | (4 << CP0C1_DL) | (3 << CP0C1_DA) |
+                (1 << CP0C1_PC) | (1 << CP0C1_WR) | (1 << CP0C1_EP),
+                .CP0_Config2 = MIPS_CONFIG2,
+                .CP0_Config3 = MIPS_CONFIG3 | (1 << CP0C3_LPA),
+                .CP0_LLAddr_rw_bitmask = 0,
+                .CP0_LLAddr_shift = 0,
+                .SYNCI_Step = 32,
+                .CCRes = 2,
+                .CP0_Status_rw_bitmask = 0x36FBFFFF,
+                .CP1_fcr0 = (1 << FCR0_F64) | (1 << FCR0_3D) | (1 << FCR0_PS) |
+                (1 << FCR0_L) | (1 << FCR0_W) | (1 << FCR0_D) |
+                (1 << FCR0_S) | (0x00 << FCR0_PRID) | (0x0 << FCR0_REV),
+                .SEGBITS = 49,
+                .PABITS = 49,
+                .CP0_CvmCtl = 2952807408,
+                .CP0_CvmMemCtl = 46104,
+		.CP0_ICacheErr = 0x007f7f0000000000,
+                .insn_flags = CPU_OCTEON | ASE_MIPS3D,
+                .mmu_type = MMU_TYPE_R4000,
+        },
+
+
+    {
+        /* XXX: We will add some more features related to
+           Octeon's coprocessors */
+        .name = "octeon",
+        .CP0_PRid = 0x0d30,
+        .CP0_Config0 = MIPS_CONFIG0 | (0x1 << CP0C0_AR) | (0x2 << CP0C0_AT) |
+                       (MMU_TYPE_R4000 << CP0C0_MT),
+        .CP0_Config1 = MIPS_CONFIG1 | (63 << CP0C1_MMU) |
+                       (2 << CP0C1_IS) | (4 << CP0C1_IL) | (3 << CP0C1_IA) |
+                       (2 << CP0C1_DS) | (4 << CP0C1_DL) | (3 << CP0C1_DA) |
+                       (1 << CP0C1_PC) | (1 << CP0C1_WR) | (1 << CP0C1_EP),
+         .CP0_Config2 = MIPS_CONFIG2,
+         .CP0_Config3 = MIPS_CONFIG3 | (1 << CP0C3_LPA),
+         .CP0_LLAddr_rw_bitmask = 0,
+         .CP0_LLAddr_shift = 0,
+         .SYNCI_Step = 32,
+         .CCRes = 2,
+         .CP0_Status_rw_bitmask = 0x36FBFFFF,
+         .CP1_fcr0 = (1 << FCR0_F64) | (1 << FCR0_3D) | (1 << FCR0_PS) |
+                     (1 << FCR0_L) | (1 << FCR0_W) | (1 << FCR0_D) |
+                     (1 << FCR0_S) | (0x00 << FCR0_PRID) | (0x0 << FCR0_REV),
+         .SEGBITS = 49,
+         .PABITS = 49,
+         .insn_flags = CPU_OCTEON | ASE_MIPS3D,
+         .mmu_type = MMU_TYPE_R4000,
+    },
     {
         .name = "Loongson-2E",
         .CP0_PRid = 0x6302,
diff -rupN qemu-1.0.1/tests/cris/.gdbinit modified_QEMU/tests/cris/.gdbinit
--- qemu-1.0.1/tests/cris/.gdbinit	2012-02-17 11:45:39.000000000 -0800
+++ modified_QEMU/tests/cris/.gdbinit	1969-12-31 16:00:00.000000000 -0800
@@ -1,11 +0,0 @@
-b main
-b _fail
-b exit
-display /i $pc
-display /x $srp
-display /x $r0
-display /x $r1
-display /x $r2
-display /x $r3
-display /x $r4
-display /t $ccs
